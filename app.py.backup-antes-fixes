import os
import uuid
import json
from flask import Flask, render_template, request, redirect, url_for, session, flash, jsonify, Response, make_response, g

# =============================================
# ðŸ†• FUNCIÃ“N SAAS - CREAR TENANT AUTOMÃTICAMENTE
# =============================================

def crear_tenant_saas(nombre_panaderia, subdominio, email_contacto=None):
    # Importar mÃ³dulos necesarios
    import sqlite3
    import os
    import shutil
    """
    Crear un nuevo tenant SaaS cuando se crea un cliente
    Returns: (Ã©xito, mensaje, tenant_id)
    """
    try:
        # 1. REGISTRAR EN BD MAESTRA
        conn_maestra = sqlite3.connect('tenant_master.db')
        cursor_maestra = conn_maestra.cursor()
        
        # Verificar si el subdominio ya existe
        cursor_maestra.execute("SELECT id FROM tenants WHERE subdominio = ?", (subdominio,))
        if cursor_maestra.fetchone():
            conn_maestra.close()
            return False, f"El subdominio '{subdominio}' ya existe", None
        
        # Nombre del archivo de BD
        nombre_bd = f"panaderia_{subdominio}.db"
        ruta_bd = os.path.join('databases_tenants', nombre_bd)
        
        # Insertar nuevo tenant
        cursor_maestra.execute(
            "INSERT INTO tenants (nombre, subdominio, base_datos, plan, activo) VALUES (?, ?, ?, ?, ?)",
            (nombre_panaderia, subdominio, nombre_bd, 'basico', 1)
        )
        
        tenant_id = cursor_maestra.lastrowid
        
        # 2. CREAR BASE DE DATOS DEL TENANT
        if not os.path.exists(ruta_bd):
            # Copiar estructura desde BD principal (sin datos)
            shutil.copy2('databases_tenants/panaderia_principal.db', ruta_bd)
            print(f"âœ… BD creada para tenant: {ruta_bd}")
        
        # 3. CREAR USUARIO ADMIN POR DEFECTO
        if email_contacto:
            cursor_maestra.execute(
                "INSERT INTO usuarios_global (email, password_hash, nombre, tenant_id, rol_global) VALUES (?, ?, ?, ?, ?)",
                (email_contacto, 'hash_temporal_actualizar', f"Admin {nombre_panaderia}", tenant_id, 'admin')
            )
        
        conn_maestra.commit()
        conn_maestra.close()
        
        print(f"ðŸŽ‰ Nuevo tenant SaaS creado: {nombre_panaderia} (ID: {tenant_id})")
        return True, f"Tenant {nombre_panaderia} creado exitosamente", tenant_id
        
    except Exception as e:
        print(f"âŒ Error creando tenant SaaS: {e}")
        return False, f"Error creando tenant: {str(e)}", None


# SAAS MIDDLEWARE - Arquitectura Multi-Tenant
from middleware_saas import init_tenants_app, gestor_tenants

from flask_login import LoginManager, login_required, current_user, login_user, logout_user
from werkzeug.security import generate_password_hash, check_password_hash
from datetime import datetime, timedelta, date, timezone
from sqlalchemy import func, extract
from reportes import GeneradorReportes
from io import BytesIO
import matplotlib.pyplot as plt
import matplotlib
matplotlib.use('Agg')

# ðŸ†• IMPORTAR MIDDLEWARE MULTICLIENTE PRIMERO
from multicliente_middleware import (
    obtener_panaderia_usuario,
    filtrar_por_panaderia, 
    requiere_panaderia,
    get_panaderia_actual
)

# =============================================
# CONFIGURACIÃ“N INICIAL DE LA APP
# =============================================

# ðŸ†• OBTENER LA RUTA BASE DEL PROYECTO
basedir = os.path.abspath(os.path.dirname(__file__))

# ðŸ†• CREAR APLICACIÃ“N FLASK
app = Flask(__name__)
# INICIALIZAR SISTEMA SAAS MULTI-TENANT
init_tenants_app(app)
print("ðŸš€ Middleware SaaS - Sistema multi-tenant activado")
app.secret_key = '023431bcb986f0ebab954d4237dffb57f86d01e38107bfc16c839c717ba8b15f'
app.config['SESSION_PERMANENT'] = False
app.config['PERMANENT_SESSION_LIFETIME'] = 3600
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///' + os.path.join(basedir, 'panaderia.db')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

# =============================================
# IMPORTAR DB PRIMERO, LUEGO MODELOS
# =============================================

# ðŸ†• SOLO IMPORTAR db PRIMERO
from models import db

# ðŸ†• AHORA IMPORTAR TODOS LOS MODELOS
from models import Usuario, Producto, Venta, DetalleVenta, MateriaPrima, Receta, RecetaIngrediente, Panaderia,  ConfiguracionPanaderia
from models import OrdenProduccion, Categoria, Proveedor, HistorialCompra, HistorialInventario
from models import ConfiguracionProduccion, HistorialRotacionProducto, ControlVidaUtil, Factura
from models import ProductoExterno, CompraExterna, RegistroDiario, SaldoBanco, PagoIndividual
from models import JornadaVentas, CierreDiario, obtener_jornada_activa, cerrar_jornada_actual, obtener_ventas_dia, obtener_historial_cierres
from models import ConsecutivoPOS, ConfiguracionSistema, Cliente
from models import calcular_rotacion_automatica, actualizar_rotaciones_automaticas
from models import calcular_tendencia_ventas, analizar_productos_periodo, calcular_rotacion_automatica_por_nombre
from models import calcular_proyeccion_ventas, generar_recomendacion_stock, generar_alertas_inteligentes
from models import obtener_productos_sin_ventas_recientes, ActivoFijo, CATEGORIAS_ACTIVOS
from facturacion.generador_xml import generar_xml_ubl_21

# =============================================
# CONFIGURACIÃ“N FLASK-LOGIN
# =============================================

login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = 'login'

# Inicializar db con la app
db.init_app(app)

@login_manager.user_loader
def load_user(user_id):
    return db.session.get(Usuario, int(user_id))

# =============================================
# ðŸ†• DEFINICIÃ“N DE MÃ“DULOS DEL SISTEMA
# =============================================

MODULOS_SISTEMA = {
    'dashboard': 'Panel Principal',
    'punto_venta': 'Punto de Venta',
    'productos': 'GestiÃ³n de Productos',
    'categorias': 'CategorÃ­as',
    'produccion': 'ProducciÃ³n y Recetas',
    'inventario': 'Inventario y Materias Primas',
    'clientes': 'GestiÃ³n de Clientes',
    'proveedores': 'Proveedores',
    'finanzas': 'Control Financiero',
    'reportes': 'Reportes y AnÃ¡lisis',
    'configuracion': 'ConfiguraciÃ³n',
    'activos': 'Activos Fijos',
    'usuarios': 'GestiÃ³n de Usuarios',
    'sistema': 'Sistema y DiagnÃ³stico'
}

# =============================================
# ðŸ†• DECORADORES PARA CONTROL DE ACCESO
# =============================================

from functools import wraps

def permisos_requeridos(modulo, accion):
    """Decorador para verificar permisos en rutas"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if not current_user.is_authenticated:
                return redirect(url_for('login'))
            
            if not current_user.tiene_permiso(modulo, accion):
                flash('âŒ No tienes permisos para realizar esta acciÃ³n', 'error')
                return redirect(url_for('dashboard'))
            
            return f(*args, **kwargs)
        return decorated_function
    return decorator

def modulo_requerido(modulo):
    """Decorador para verificar acceso al mÃ³dulo completo - VERSIÃ“N MEJORADA"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if not current_user.is_authenticated:
                return redirect(url_for('login'))
            
            # âœ… SUPER_ADMIN tiene acceso a TODO (incluyendo gestiÃ³n de clientes)
            if current_user.rol == 'super_admin':
                return f(*args, **kwargs)
            
            # âœ… ADMIN_CLIENTE NO puede acceder a gestiÃ³n de clientes de otros
            if modulo == 'gestion_clientes' and current_user.rol == 'admin_cliente':
                flash('âŒ Solo el soporte tÃ©cnico puede acceder a la gestiÃ³n de clientes', 'error')
                return redirect(url_for('dashboard'))
            
            if not current_user.puede_acceder_modulo(modulo):
                flash(f'âŒ No tienes acceso al mÃ³dulo {MODULOS_SISTEMA.get(modulo, modulo)}', 'error')
                return redirect(url_for('acceso_denegado'))
            
            return f(*args, **kwargs)
        return decorated_function
    return decorator

# =============================================
# ðŸ†• CONTEXT PROCESSOR PARA PERMISOS EN TEMPLATES
# =============================================

@app.context_processor
def inject_permisos():
    """Inyectar funciones de permisos en todos los templates"""
    def usuario_puede(modulo, accion):
        if not current_user.is_authenticated:
            return False
        return current_user.tiene_permiso(modulo, accion)
    
    def usuario_tiene_acceso(modulo):
        if not current_user.is_authenticated:
            return False
        return current_user.puede_acceder_modulo(modulo)
    
    def modulos_permitidos():
        if not current_user.is_authenticated:
            return []
        return current_user.obtener_modulos_permitidos()
    
    return dict(
        usuario_puede=usuario_puede,
        usuario_tiene_acceso=usuario_tiene_acceso,
        modulos_permitidos=modulos_permitidos,
        MODULOS_SISTEMA=MODULOS_SISTEMA
    )

@app.before_request
def antes_de_cada_peticion():
    # =============================================
    # ðŸ†• SAAS - DETECCIÃ“N MEJORADA DE TENANT
    # =============================================
    from middleware_saas import gestor_tenants
    
    tenant_detectado = None
    
    # PRIMERO: DetecciÃ³n por subdominio (siempre disponible)
    tenant_detectado = gestor_tenants.obtener_tenant_desde_request()
    if tenant_detectado:
        print(f"ðŸ” Tenant detectado por subdominio: {tenant_detectado['nombre']}")
    
    # SEGUNDO: Si hay usuario autenticado, priorizar su tenant
    # Verificar de forma segura si current_user estÃ¡ disponible
    try:
        if hasattr(current_user, 'is_authenticated') and current_user.is_authenticated and hasattr(current_user, 'panaderia_id'):
            try:
                import sqlite3
                conn = sqlite3.connect('tenant_master.db')
                cursor = conn.cursor()
                cursor.execute('SELECT id, nombre, subdominio, base_datos FROM tenants WHERE id = ? AND activo = 1', (current_user.panaderia_id,))
                
                tenant_data = cursor.fetchone()
                conn.close()
                
                if tenant_data:
                    tenant_detectado = {
                        'id': tenant_data[0],
                        'nombre': tenant_data[1],
                        'subdominio': tenant_data[2],
                        'base_datos': tenant_data[3]
                    }
                    print(f"ðŸ” Tenant detectado por usuario: {tenant_detectado['nombre']} (panaderia_id: {current_user.panaderia_id})")
            except Exception as e:
                print(f"âš ï¸ Error detectando tenant por usuario: {e}")
    except Exception as e:
        print(f"âš ï¸ current_user no disponible aÃºn: {e}")
    
    # TERCERO: Si no hay tenant detectado, usar principal por defecto
    if not tenant_detectado:
        tenant_detectado = {
            'id': 1,
            'nombre': 'PanaderÃ­a Principal',
            'subdominio': 'principal',
            'base_datos': 'panaderia_principal.db'
        }
        print("ðŸ” Tenant por defecto: PanaderÃ­a Principal")
    
    # Configurar en contexto global
    g.tenant = tenant_detectado
    
    # Configurar SQLAlchemy para el tenant detectado
    app.config['SQLALCHEMY_DATABASE_URI'] = f"sqlite:///databases_tenants/{tenant_detectado['base_datos']}"
    print(f"ðŸ”§ SaaS - BD configurada: {tenant_detectado['base_datos']}")
    
    """Middleware global unificado - VERSIÃ“N MEJORADA"""
    # 1. Establecer informaciÃ³n de usuario y panaderÃ­a
    from multicliente_middleware import obtener_info_usuario
    obtener_info_usuario()

    # 2. Verificar suscripciÃ³n (solo si current_user estÃ¡ disponible)
    try:
        if hasattr(current_user, 'is_authenticated') and current_user.is_authenticated and hasattr(current_user, 'panaderia_id'):
            from models import obtener_configuracion_panaderia

            try:
                config = obtener_configuracion_panaderia(current_user.panaderia_id)
                if config is not None:
                    config.actualizar_estado_suscripcion()

                    if config.tipo_licencia != 'local' and not config.suscripcion_activa:
                        rutas_permitidas = ['logout', 'static', 'suscripcion_vencida']
                        if request.endpoint and not any(ruta in request.endpoint for ruta in rutas_permitidas):
                            return redirect(url_for('suscripcion_vencida'))
            except Exception as e:
                print(f"âš ï¸ Error verificando suscripciÃ³n: {e}")
    except Exception as e:
        print(f"âš ï¸ current_user no disponible para verificaciÃ³n de suscripciÃ³n: {e}")


# =============================================
# ðŸš€ INICIALIZACIÃ“N SAAS (EJECUCIÃ“N ÃšNICA)
# =============================================

with app.app_context():
    db.create_all()
    
    # Verificar si ya existe un usuario admin
    admin = Usuario.query.filter_by(username='admin').first()
    if not admin:
        hashed_password = generate_password_hash('admin123')
        admin_user = Usuario(
            username='admin', 
            password_hash=hashed_password, 
            nombre_completo='Administrador Principal',
            rol='administrador'
        )
        db.session.add(admin_user)
        db.session.commit()
        print("âœ… Usuario admin creado: usuario: admin, contraseÃ±a: admin123")
    
    # ðŸ†• VERIFICAR Y CREAR MODELOS NUEVOS DEL SISTEMA POS
    consecutivo = ConsecutivoPOS.query.first()
    if not consecutivo:
        consecutivo_inicial = ConsecutivoPOS(numero_actual=0)
        db.session.add(consecutivo_inicial)
        print("âœ… Consecutivo POS inicial creado")
    
    config_sistema = ConfiguracionSistema.query.first()
    if not config_sistema:
        config_inicial = ConfiguracionSistema(
            tipo_facturacion='POS',
            nombre_empresa='PanaderÃ­a y Pasteleria Semillas',
            nit_empresa='900000000-1',
            direccion_empresa='Cra. 18 # 9-45 Atahualpa',
            telefono_empresa='+57 3189098818',
            ciudad_empresa='Pasto',
            regimen_empresa='Simplificado'
        )
        db.session.add(config_inicial)
        print("âœ… ConfiguraciÃ³n del sistema inicial creada")
    
    # Crear categorÃ­as y productos de prueba si no existen
    if not Categoria.query.first():
        # Crear categorÃ­as
        panaderia = Categoria(nombre="PanaderÃ­a")
        pasteleria = Categoria(nombre="PastelerÃ­a")
        bebidas = Categoria(nombre="Bebidas")
        
        db.session.add_all([panaderia, pasteleria, bebidas])
        db.session.commit()
        
        # Crear productos de prueba
        productos = [
            Producto(nombre="Pan Mantequilla", categoria_id=panaderia.id, precio_venta=300, codigo_barras="1001"),
            Producto(nombre="Pan Integral", categoria_id=panaderia.id, precio_venta=4000, codigo_barras="1002"),
            Producto(nombre="Croissant", categoria_id=panaderia.id, precio_venta=1000, codigo_barras="1003"),
            Producto(nombre="Pastel de Chocolate", categoria_id=pasteleria.id, precio_venta=30000, codigo_barras="2001"),
            Producto(nombre="Galletas", categoria_id=pasteleria.id, precio_venta=1200, codigo_barras="2002"),
            Producto(nombre="CafÃ©", categoria_id=bebidas.id, precio_venta=1000, codigo_barras="3001"),
            Producto(nombre="Jugo de Naranja", categoria_id=bebidas.id, precio_venta=4000, codigo_barras="3002")
        ]
        
        db.session.add_all(productos)
        db.session.commit()
        print("âœ… Productos de prueba creados automÃ¡ticamente")
    
    # âŒ ELIMINADO: PROVEEDORES PRE-CONFIGURADOS
    # Cada tenant debe empezar limpio y crear sus propios proveedores
    # if not Proveedor.query.first():
    #     proveedores_ejemplo = [
    #         Proveedor(
    #             nombre="Haz de Oros",
    #             contacto="Juan PÃ©rez",
    #             telefono="3001234567",
    #             email="ventas@hazdeoros.com",
    #             direccion="Calle 123 #45-67, BogotÃ¡",
    #             productos_que_suministra="Harina de trigo, harina integral, salvado",
    #             tiempo_entrega_dias=2,
    #             evaluacion=5
    #         ),
    #         Proveedor(
    #             nombre="Lacteos La Sabana",
    #             contacto="MarÃ­a GonzÃ¡lez",
    #             telefono="3109876543", 
    #             email="pedidos@lacteoslasabana.com",
    #             direccion="Av. 68 #12-34, MedellÃ­n",
    #             productos_que_suministra="Leche, mantequilla, queso, crema de leche",
    #             tiempo_entrega_dias=1,
    #             evaluacion=4
    #         ),
    #         Proveedor(
    #             nombre="Dulces del Valle",
    #             contacto="Carlos RodrÃ­guez",
    #             telefono="3205558888",
    #             email="info@dulcesdelvalle.com",
    #             direccion="Cr. 45 #78-90, Cali", 
    #             productos_que_suministra="AzÃºcar, panela, miel, esencias",
    #             tiempo_entrega_dias=3,
    #             evaluacion=4
    #         )
    #     ]
    #     
    #     db.session.add_all(proveedores_ejemplo)
    #     db.session.commit()
    #     print("âœ… Proveedores de ejemplo creados automÃ¡ticamente")
    
    # ðŸ†• HACER COMMIT FINAL DE TODOS LOS CAMBIOS
    db.session.commit()
    
    print("âœ… Base de datos lista!")
    print(f"ðŸ“ UbicaciÃ³n de la BD: {os.path.join(basedir, 'panaderia.db')}")
# =============================================
# ðŸ†• RUTA DE SUSCRIPCIÃ“N VENCIDA
# =============================================

@app.route('/suscripcion_vencida')
@login_required
def suscripcion_vencida():
    """PÃ¡gina que se muestra cuando la suscripciÃ³n estÃ¡ vencida"""
    from models import obtener_configuracion_panaderia
    config = obtener_configuracion_panaderia(current_user.panaderia_id)
    return render_template('suscripcion_vencida.html', 
                         config=config,
                         dias_restantes=config.dias_para_expiracion)

# =============================================
# RUTAS PRINCIPALES DEL SISTEMA - SIN DUPLICADOS
# =============================================

# Ruta para el login - SOLO UNA VEZ
# =============================================
# RUTAS PRINCIPALES DEL SISTEMA - SIN DUPLICADOS
# =============================================

def es_super_usuario():
    """Verifica si el usuario actual es super usuario (dev_master)"""
    user_id = session.get('user_id')
    if not user_id:
        return False
    
    usuario = Usuario.query.get(user_id)
    
    # Identificar por nombre de usuario (dev_master)
    if usuario and usuario.username == 'dev_master':
        return True
    
    return False

def diagnosticar_recetas(panaderia_id):
    """DiagnÃ³stico para ver quÃ© recetas existen"""
    print(f"ðŸ” DIAGNÃ“STICO RECETAS - PanaderÃ­a {panaderia_id}:")
    
    todas_recetas = Receta.query.filter_by(panaderia_id=panaderia_id).all()
    print(f"   Total recetas en BD: {len(todas_recetas)}")
    
    for receta in todas_recetas:
        print(f"   - '{receta.nombre}' (ID: {receta.id}, Activo: {receta.activo})")
    
    recetas_activas = Receta.query.filter_by(panaderia_id=panaderia_id, activo=True).all()
    print(f"   Recetas activas: {len(recetas_activas)}")
    
    return len(recetas_activas)

# âœ… âœ… âœ… AGREGA diagnosticar_recetas EXACTAMENTE AQUÃ âœ… âœ… âœ…
def diagnosticar_recetas(panaderia_id):
    """DiagnÃ³stico para ver quÃ© recetas existen"""
    print(f"ðŸ” DIAGNÃ“STICO RECETAS - PanaderÃ­a {panaderia_id}:")
    
    # Ver todas las recetas de esta panaderÃ­a
    todas_recetas = Receta.query.filter_by(panaderia_id=panaderia_id).all()
    print(f"   Total recetas en BD: {len(todas_recetas)}")
    
    for receta in todas_recetas:
        print(f"   - '{receta.nombre}' (ID: {receta.id}, Activo: {receta.activo})")
    
    # Ver recetas activas
    recetas_activas = Receta.query.filter_by(panaderia_id=panaderia_id, activo=True).all()
    print(f"   Recetas activas: {len(recetas_activas)}")
    
    return len(recetas_activas)

def obtener_panaderia_actual():
    """Obtener panaderÃ­a actual considerando acceso remoto SOLO para super usuario"""
    if es_super_usuario() and 'panaderia_remota' in session:
        return session['panaderia_remota']
    return session.get('panaderia_id')

# âœ… âœ… âœ… FIN DE diagnosticar_recetas âœ… âœ… âœ…
# Ruta para el login - SOLO UNA VEZ
@app.route('/', methods=['GET', 'POST'])
def login():
    """ðŸŽ¯ SISTEMA DE LOGIN PROFESIONAL - ARQUITECTURA EXTENSIBLE"""
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        
        print(f"ðŸ” [LOGIN] Buscando usuario: {username}")
        print(f"ðŸ” [LOGIN] URI de BD: {app.config['SQLALCHEMY_DATABASE_URI']}")
        
        # VER TODOS LOS USUARIOS EN LA BD ACTUAL
        todos_usuarios = Usuario.query.all()
        print(f"ðŸ” [LOGIN] Usuarios en BD actual: {[u.username for u in todos_usuarios]}")
        
        user = Usuario.query.filter_by(username=username).first()
        
        if user:
            print(f"âœ… [LOGIN] USUARIO ENCONTRADO: {user.username}")
            print(f"ðŸ“¦ [LOGIN] Hash en BD: {user.password_hash}")
            print(f"ðŸª [LOGIN] PanaderÃ­a ID: {user.panaderia_id}")
            
            # ðŸŽ¯ ARQUITECTURA PROFESIONAL - MÃšLTIPLES MÃ‰TODOS DE VERIFICACIÃ“N
            login_exitoso, metodo_usado = verificar_credenciales(user, password)
            
            if login_exitoso:
                print(f"âœ… [LOGIN] VerificaciÃ³n exitosa con mÃ©todo: {metodo_usado}")
                
                # ðŸ” REGISTRO DE ACTIVIDAD (PREPARACIÃ“N PARA AUDITORÃA)
                registrar_intento_login(user.id, True, metodo_usado)
                
                login_user(user)
                session['user_id'] = user.id
                session['username'] = user.username
                session['rol'] = user.rol
                session['panaderia_id'] = user.panaderia_id
                
                print(f"âœ… [LOGIN] Login exitoso: {username}")
                flash('Inicio de sesiÃ³n exitoso!', 'success')
                return redirect(url_for('dashboard'))
            else:
                # ðŸ” REGISTRO DE INTENTO FALLIDO
                registrar_intento_login(user.id, False, 'fallido')
                print(f"âŒ [LOGIN] Todas las verificaciones fallaron")
        
        else:
            print(f"âŒ [LOGIN] USUARIO NO ENCONTRADO en la BD actual")
            # ðŸ” REGISTRO DE INTENTO FALLIDO (usuario no existe)
            registrar_intento_login(None, False, 'usuario_no_existe')
        
        flash('Usuario o contraseÃ±a incorrectos', 'error')
        print(f"âŒ [LOGIN] Login fallido para: {username}")
    
    return render_template('login.html')

def verificar_credenciales(user, password):
    """
    ðŸŽ¯ MÃ‰TODO PROFESIONAL EXTENSIBLE - SOPORTE MÃšLTIPLES TIPOS DE HASH
    Retorna: (Ã©xito, mÃ©todo_usado)
    """
    # 1. VERIFICACIÃ“N CON HASH SEGURO (werkzeug) - PARA USUARIOS NUEVOS/RESETEADOS
    try:
        from werkzeug.security import check_password_hash
        if check_password_hash(user.password_hash, password):
            return True, 'hash_seguro'
    except Exception as e:
        print(f"âš ï¸ [VERIFICACIÃ“N] Error con hash seguro: {e}")
    
    # 2. VERIFICACIÃ“N CON HASH SIMPLE (desarrollo/transiciÃ³n) - PARA USUARIOS EXISTENTES
    if user.password_hash.startswith('dev_'):
        expected_hash = f"dev_{password}_hash"
        if user.password_hash == expected_hash:
            return True, 'hash_simple'
        else:
            print(f"âŒ [VERIFICACIÃ“N] Hash simple no coincide")
            print(f"   Esperado: {expected_hash}")
    
    # 3. ðŸ†• ESPACIO RESERVADO PARA MÃ‰TODOS FUTUROS
    # - VerificaciÃ³n con OTP (One-Time Password)
    # - VerificaciÃ³n con API externa (SSO)
    # - VerificaciÃ³n con biometrics
    # - VerificaciÃ³n con tokens JWT
    
    return False, 'ninguno'

def registrar_intento_login(user_id, exitoso, metodo):
    """
    ðŸŽ¯ PREPARACIÃ“N PARA SISTEMA DE AUDITORÃA PROFESIONAL
    En FASE 2, esto se migrarÃ¡ a tabla de auditorÃ­a en base de datos
    """
    try:
        # ðŸ“Š LOG TEMPORAL - EN FASE 2 SE MIGRA A BASE DE DATOS
        print(f"ðŸ“Š [AUDITORÃA] Login - UserID: {user_id}, Exitoso: {exitoso}, MÃ©todo: {metodo}")
        
        # ðŸ†• CÃ“DIGO PREPARADO PARA FASE 2 (ACTUALMENTE COMENTADO)
        # from datetime import datetime
        # from models import AuditoriaLogin  # ðŸŽ¯ TABLA POR CREAR EN FASE 2
        # 
        # auditoria = AuditoriaLogin(
        #     usuario_id=user_id,
        #     exitoso=exitoso,
        #     metodo_autenticacion=metodo,
        #     ip_address=request.remote_addr,
        #     user_agent=request.headers.get('User-Agent'),
        #     fecha_hora=datetime.utcnow()
        # )
        # db.session.add(auditoria)
        # db.session.commit()
        
    except Exception as e:
        print(f"âš ï¸ [AUDITORÃA] Error registrando intento: {e}")

# Ruta de fallback segura
@app.route('/acceso_denegado')
@login_required
def acceso_denegado():
    return render_template('acceso_denegado.html')

# Ruta para el dashboard - SOLO UNA VEZ
@app.route('/dashboard')
@login_required
def dashboard():
    return render_template('dashboard.html', username=session.get('username', 'Usuario'))

# Ruta para el punto de venta
@app.route('/punto_venta')
@login_required
@modulo_requerido('punto_venta')
def punto_venta():
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    # âœ… OBTENER panaderia_id DE LA SESIÃ“N (CON ACCESO REMOTO)
    panaderia_actual = obtener_panaderia_actual()  # â† ÃšNICO CAMBIO AQUÃ
    
    # âœ… âœ… âœ… NUEVO: BLOQUE SUPER USUARIO (AGREGA ESTO) âœ… âœ… âœ…
    if es_super_usuario() and not session.get('panaderia_remota'):
        flash("ðŸ”§ Como super usuario, usa 'Acceder a esta panaderÃ­a' para usar el punto de venta", "info")
        return render_template('punto_venta.html',
                             productos_internos=[],
                             productos_externos=[],
                             categorias=[],
                             clientes=[])
    # âœ… âœ… âœ… FIN BLOQUE SUPER USUARIO âœ… âœ… âœ…
    
    # âœ… OBTENER PRODUCTOS FILTRADOS POR PANADERÃA
    productos_internos = Producto.query.filter_by(
        activo=True, 
        panaderia_id=panaderia_actual,
        tipo_producto='produccion'
    ).all()
    
    productos_externos = ProductoExterno.query.filter_by(
        activo=True, 
        panaderia_id=panaderia_actual
    ).all()
    
    # âœ… OBTENER CATEGORÃAS PARA ORGANIZAR PRODUCTOS
    categorias = Categoria.query.filter_by(panaderia_id=panaderia_actual).all()
    
    # âœ… OBTENER CLIENTES PARA EL SELECT
    clientes = Cliente.query.filter_by(activo=True).all()
    
    # Debug temporal para verificar
    print(f"DEBUG PUNTO VENTA: PanaderÃ­a {panaderia_actual}")
    print(f"DEBUG: {len(productos_internos)} productos internos")
    print(f"DEBUG: {len(productos_externos)} productos externos")
    print(f"DEBUG: {len(categorias)} categorÃ­as")
    
    return render_template('punto_venta.html',
                         productos_internos=productos_internos,
                         productos_externos=productos_externos,
                         categorias=categorias,
                         clientes=clientes)

# EN app.py - AGREGAR ESTA RUTA DE DIAGNÃ“STICO URGENTE
@app.route('/debug_punto_venta')
@login_required
@modulo_requerido('punto_venta')
def debug_punto_venta():
    """DiagnÃ³stico urgente del punto de venta"""
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    # 1. Verificar todos los productos
    todos_productos = Producto.query.all()
    
    # 2. Productos que deberÃ­an aparecer en bÃºsqueda
    productos_busqueda = Producto.query.filter(
        Producto.activo == True,
        Producto.stock_actual > 0
    ).all()
    
    # 3. Productos de producciÃ³n especÃ­ficamente
    productos_produccion = Producto.query.filter_by(tipo_producto='produccion').all()
    
    # 4. Recetas con productos asociados
    recetas_con_producto = Receta.query.filter(Receta.producto_id.isnot(None)).all()
    
    debug_info = {
        'total_productos': len(todos_productos),
        'productos_activos_con_stock': len(productos_busqueda),
        'productos_produccion': len(productos_produccion),
        'recetas_con_producto': len(recetas_con_producto),
        'detalle_productos': [],
        'detalle_recetas': []
    }
    
    for producto in todos_productos:
        debug_info['detalle_productos'].append({
            'id': producto.id,
            'nombre': producto.nombre,
            'tipo': producto.tipo_producto,
            'activo': producto.activo,
            'stock_actual': producto.stock_actual,
            'precio': producto.precio_venta,
            'tiene_receta': producto.receta_id is not None,
            'aparece_en_busqueda': producto.activo and producto.stock_actual > 0
        })
    
    for receta in recetas_con_producto:
        debug_info['detalle_recetas'].append({
            'id': receta.id,
            'nombre': receta.nombre,
            'producto_id': receta.producto_id,
            'producto_nombre': receta.producto.nombre if receta.producto else 'NO',
            'producto_stock': receta.producto.stock_actual if receta.producto else 0
        })
    
    return render_template('debug_punto_venta.html', debug=debug_info)

# Ruta para buscar productos (API)
@app.route('/buscar_producto')
@login_required
@modulo_requerido('punto_venta')
def buscar_producto():
    """BÃºsqueda unificada de productos (panaderÃ­a + externos) - VERSIÃ“N FUNCIONAL"""
    query = request.args.get('q', '').lower()
        # ðŸ” DIAGNÃ“STICO COMPLETO
    user_id = session.get('user_id')
    panaderia_id = obtener_panaderia_actual()
    print(f"ðŸ” DIAGNÃ“STICO buscar_producto:")
    print(f"   ðŸ‘¤ User ID: {user_id}")
    print(f"   ðŸª PanaderÃ­a ID: {panaderia_id}")
    print(f"   ðŸ‘‘ Es super usuario: {es_super_usuario()}")
    print(f"   ðŸ” Query: '{query}'")
    
    # âœ… âœ… âœ… NUEVO: BLOQUE SUPER USUARIO (AGREGA ESTO) âœ… âœ… âœ…
    if es_super_usuario():
        print("ðŸ” Super usuario realizando bÃºsqueda - retornando vacÃ­o")
        return jsonify([])  # Super usuario no ve productos en bÃºsqueda
    # âœ… âœ… âœ… FIN BLOQUE SUPER USUARIO âœ… âœ… âœ…
    
    try:
        resultados = []
        
        print(f"ðŸ” Iniciando bÃºsqueda con query: '{query}'")
        
        # PRODUCTOS DE PANADERÃA
        from utilidades.consultas_filtradas import productos_activos_con_stock
        productos_panaderia = productos_activos_con_stock().all()
        print(f"ðŸž Productos panaderÃ­a encontrados: {len(productos_panaderia)}")
        
        # PRODUCTOS EXTERNOS
        from utilidades.consultas_filtradas import productos_externos_activos_con_stock
        productos_externos = productos_externos_activos_con_stock().all()
        print(f"ðŸ¥¤ Productos externos encontrados: {len(productos_externos)}")
        
        # AGREGAR PRODUCTOS DE PANADERÃA
        for producto in productos_panaderia:
            nombre_lower = producto.nombre.lower()
            if query in nombre_lower or query == '':
                resultados.append({
                    'id': producto.id,
                    'nombre': producto.nombre,
                    'precio': float(producto.precio_venta),
                    'stock_actual': producto.stock_actual,
                    'categoria': getattr(producto.categoria, 'nombre', 'PanaderÃ­a') if hasattr(producto, 'categoria') and producto.categoria else 'PanaderÃ­a',
                    'tipo_producto': getattr(producto, 'tipo_producto', 'produccion'),
                    'es_externo': False
                })
                print(f"âœ… Agregado panaderÃ­a: {producto.nombre}")
        
        # AGREGAR PRODUCTOS EXTERNOS
        for producto in productos_externos:
            nombre_lower = producto.nombre.lower()
            if query in nombre_lower or query == '':
                resultados.append({
                    'id': producto.id + 10000,  # Offset para evitar conflictos
                    'nombre': producto.nombre,
                    'precio': float(producto.precio_venta),
                    'stock_actual': producto.stock_actual,
                    'categoria': producto.categoria,
                    'tipo_producto': 'produccion',  # Mismo tipo para compatibilidad
                    'es_externo': True,
                    'producto_externo_id': producto.id
                })
                print(f"âœ… Agregado externo: {producto.nombre}")
        
        print(f"ðŸŽ¯ Total resultados: {len(resultados)}")
        
        # DEBUG: Mostrar primeros resultados
        for i, r in enumerate(resultados[:3]):
            print(f"  {i+1}. {r['nombre']} (ID: {r['id']}, Precio: {r['precio']})")
        
        return jsonify(resultados)
        
    except Exception as e:
        print(f"âŒ Error en bÃºsqueda de productos: {e}")
        import traceback
        traceback.print_exc()
        return jsonify([])

@app.route('/debug_productos_punto_venta')
@login_required
@modulo_requerido('punto_venta')
def debug_productos_punto_venta():
    """Debug: Verificar quÃ© productos estÃ¡n disponibles para punto de venta"""
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    # Productos de panaderÃ­a
    from utilidades.consultas_filtradas import productos_activos_con_stock
    productos_panaderia = productos_activos_con_stock().all()
    
    # Productos externos
    from utilidades.consultas_filtradas import productos_externos_activos_con_stock
    productos_externos = productos_externos_activos_con_stock().all()
    
    resultado = {
        'panaderia_count': len(productos_panaderia),
        'externos_count': len(productos_externos),
        'panaderia': [{'id': p.id, 'nombre': p.nombre, 'stock': p.stock_actual} for p in productos_panaderia],
        'externos': [{'id': p.id, 'nombre': p.nombre, 'stock': p.stock_actual} for p in productos_externos]
    }
    
    return jsonify(resultado)
    
# === ðŸ†• FUNCIONES PARA MANEJO DE CONSECUTIVOS POS ===


def obtener_consecutivo_pos():
    """
    Obtiene y incrementa automÃ¡ticamente el consecutivo POS
    Si no existe, crea el registro inicial con valor 0
    """
    try:
        consecutivo = ConsecutivoPOS.query.first()
        if not consecutivo:
            # ðŸ†• Crear registro inicial si no existe
            consecutivo = ConsecutivoPOS(numero_actual=0)
            db.session.add(consecutivo)
            db.session.commit()
            print("âœ… Registro de consecutivo POS creado inicialmente")
        
        # Incrementar consecutivo
        consecutivo.numero_actual += 1
        consecutivo.updated_at = datetime.utcnow()
        db.session.commit()
        
        print(f"âœ… Consecutivo POS actualizado: {consecutivo.numero_actual}")
        return consecutivo.numero_actual
        
    except Exception as e:
        print(f"âŒ Error en obtener_consecutivo_pos: {e}")
        db.session.rollback()
        # ðŸ†• MEJORA: Usar timestamp como fallback mÃ¡s Ãºnico
        fallback = int(datetime.utcnow().timestamp() % 1000000)
        print(f"ðŸ”„ Usando consecutivo fallback: {fallback}")
        return fallback

def obtener_configuracion_sistema():
    """
    Obtiene la configuraciÃ³n del sistema desde la base de datos
    Si no existe, crea una configuraciÃ³n por defecto
    """
    try:
        config = ConfiguracionSistema.query.first()
        if not config:
            # Crear configuraciÃ³n por defecto
            config = ConfiguracionSistema(
                tipo_facturacion='POS',
                nombre_empresa='Panaderia Semillas',
                nit_empresa='9000000001',
                direccion_empresa='Cra 18 # 9-45, Atahualpa',
                telefono_empresa='+57 3189098818',
                ciudad_empresa='Pasto',
                regimen_empresa='Simplificado'
            )
            db.session.add(config)
            db.session.commit()
        return config
    except Exception as e:
        print(f"Error obteniendo configuraciÃ³n: {e}")
        # Retornar objeto por defecto en caso de error
        return type('ConfigDefault', (), {
            'nit_empresa': '9000000001',
            'nombre_empresa': 'Panaderia Semillas',
            'direccion_empresa': 'Cra 18 # 9-45, Atahualpa',
            'telefono_empresa': '+57 3189098818',
            'ciudad_empresa': 'Pasto'
        })()

def reiniciar_consecutivo_pos():
    """
    âš ï¸ SOLO PARA PRUEBAS: Reinicia el consecutivo a 0
    """
    try:
        consecutivo = ConsecutivoPOS.query.first()
        if consecutivo:
            consecutivo.numero_actual = 0
            db.session.commit()
            print("âœ… Consecutivo POS reiniciado a 0")
        return True
    except Exception as e:
        print(f"âŒ Error reiniciando consecutivo: {e}")
        return False
    


# âœ… RUTA ACTUALIZADA: /registrar_venta con aprendizaje automÃ¡tico
    
@app.route('/registrar_venta', methods=['POST'])
@login_required
@modulo_requerido('punto_venta')
def registrar_venta():
    print("ðŸ›’ DEBUG - INICIANDO REGISTRO DE VENTA")
    print(f"ðŸ‘¤ User ID en sesiÃ³n: {session.get('user_id')}")
    
    # ðŸŽ¯ OBTENER USUARIO ACTUAL PARA panaderia_id
    usuario_actual = Usuario.query.get(session['user_id'])
    print(f"ðŸª DEBUG - PanaderÃ­a ID del usuario: {usuario_actual.panaderia_id}")
    
    """Registrar venta con productos mixtos (panaderÃ­a + externos) - VERSIÃ“N MEJORADA CON CLIENTES Y DONACIONES"""
    if 'user_id' not in session:
        return jsonify({'success': False, 'error': 'No autorizado'})
    
    try:
        data = request.get_json()
        carrito = data.get('carrito', [])
        metodo_pago = data.get('metodo_pago', 'efectivo')
        cliente_id = data.get('cliente_id')
        tipo_documento_solicitado = data.get('tipo_documento')
        
        # ðŸŽ NUEVO: CAPTURAR DATOS DE DONACIÃ“N
        es_donacion = data.get('es_donacion', False)
        motivo_donacion = data.get('motivo_donacion', '')
        
        print(f'ðŸ›’ Datos de venta recibidos - Cliente: {cliente_id}, Tipo: {tipo_documento_solicitado}, DonaciÃ³n: {es_donacion}')
        
        # ðŸ†• OBTENER CONFIGURACIÃ“N DEL SISTEMA
        config = obtener_configuracion_sistema()
        
        # ðŸ†• VALIDACIÃ“N PARA FACTURA ELECTRÃ“NICA
        if tipo_documento_solicitado == 'ELECTRONICA':
            if not cliente_id:
                return jsonify({
                    'success': False, 
                    'error': 'Para factura electrÃ³nica se requiere seleccionar un cliente'
                })
            
            if config.tipo_facturacion != 'ELECTRONICA':
                return jsonify({
                    'success': False,
                    'error': 'El sistema no estÃ¡ configurado para facturaciÃ³n electrÃ³nica'
                })
        
        # ðŸ†• DETERMINAR TIPO DE DOCUMENTO FINAL
        if tipo_documento_solicitado == 'ELECTRONICA' and config.tipo_facturacion == 'ELECTRONICA':
            tipo_documento = 'ELECTRONICA'
            consecutivo_pos = None
            texto_legal = "Factura electrÃ³nica de venta - RÃ©gimen simplificado"
        else:
            tipo_documento = 'POS'
            consecutivo_pos = obtener_consecutivo_pos()  # ðŸ†• OBTENER CONSECUTIVO
            texto_legal = "Documento equivalente POS â€“ No vÃ¡lido como factura electrÃ³nica de venta"
        
        # ðŸŽ NUEVO: CALCULAR TOTAL (CERO SI ES DONACIÃ“N)
        total_venta = 0
        if not es_donacion:
            # Calcular total normal sumando todos los productos
            for item in carrito:
                producto_id = item['id']
                cantidad = item['cantidad']
                
                # DETERMINAR SI ES PRODUCTO EXTERNO (ID > 10000)
                if producto_id > 10000:
                    producto_externo_id = producto_id - 10000
                    producto = ProductoExterno.query.get(producto_externo_id)
                    if producto:
                        total_venta += cantidad * producto.precio_venta
                else:
                    producto = Producto.query.get(producto_id)
                    if producto:
                        total_venta += cantidad * producto.precio_venta
        else:
            # ðŸŽ PARA DONACIONES: TOTAL = 0
            total_venta = 0
            print(f"ðŸŽ REGISTRANDO DONACIÃ“N - Motivo: {motivo_donacion}")
            print(f"ðŸŽ Productos en donaciÃ³n: {[item.get('nombre', 'N/A') for item in carrito]}")
        
        # ðŸŽ¯ SOLUCIÃ“N DEFINITIVA - FECHA/HORA CON TIMEZONE CORRECTO
        # Crear datetime con timezone de Colombia (UTC-5)
        tz_colombia = timezone(timedelta(hours=-5))
        fecha_hora = datetime.now(tz_colombia)
        
        # ðŸ†• CREAR VENTA CON FECHA CORREGIDA
        nueva_venta = Venta(
            usuario_id=session['user_id'],
            total=total_venta,
            metodo_pago=metodo_pago,
            cliente_id=cliente_id,
            panaderia_id=usuario_actual.panaderia_id,
            tipo_documento=tipo_documento,
            consecutivo_pos=consecutivo_pos,
            texto_legal=texto_legal,
            es_donacion=es_donacion,
            motivo_donacion=motivo_donacion,
            fecha_hora=fecha_hora  # â† FECHA CORREGIDA DEFINITIVAMENTE
        )
        db.session.add(nueva_venta)
        db.session.flush()  # Para obtener el ID
        
        print(f"âœ… Venta creada con panaderia_id: {nueva_venta.panaderia_id}")
        print(f"ðŸ“… Fecha registrada: {fecha_hora}")
        
                
        print(f"âœ… Venta creada con panaderia_id: {nueva_venta.panaderia_id}")
        
        detalles_venta = []
        
        # ðŸŽ PROCESAR CADA PRODUCTO DEL CARRITO (EL INVENTARIO SE DESCUENTA NORMALMENTE)
        for item in carrito:
            producto_id = item['id']
            cantidad = item['cantidad']
            
            # DETERMINAR SI ES PRODUCTO EXTERNO (ID > 10000)
            if producto_id > 10000:
                # Es producto externo
                producto_externo_id = producto_id - 10000
                producto = ProductoExterno.query.get(producto_externo_id)
                
                if not producto or producto.stock_actual < cantidad:
                    return jsonify({
                        'success': False, 
                        'error': f'Stock insuficiente: {producto.nombre if producto else "Producto"}'
                    })
                
                # ðŸŽ ACTUALIZAR STOCK EXTERNO (SE DESCUENTA NORMALMENTE TAMBIÃ‰N EN DONACIONES)
                producto.stock_actual -= cantidad
                
                # ðŸŽ ACTUALIZAR MÃ‰TRICAS SOLO SI NO ES DONACIÃ“N
                if not es_donacion:
                    producto.total_ventas += cantidad
                    producto.total_ingresos += cantidad * producto.precio_venta
                    producto.utilidad_total += cantidad * (producto.precio_venta - producto.precio_compra)
                    producto.fecha_ultima_venta = datetime.utcnow()
                
                # ðŸŽ PRECIO UNITARIO: para donaciones registramos el precio real pero total=0
                precio_unitario = producto.precio_venta
                
                # Crear detalle de venta
                detalle = DetalleVenta(
                    venta_id=nueva_venta.id,
                    producto_id=None,  # No asociado a Producto tradicional
                    producto_externo_id=producto_externo_id,
                    cantidad=cantidad,
                    precio_unitario=precio_unitario  # ðŸŽ Registramos el precio real
                )
                detalles_venta.append(detalle)
                
            else:
                # Es producto normal de panaderÃ­a
                producto = Producto.query.get(producto_id)
                
                if not producto or producto.stock_actual < cantidad:
                    return jsonify({
                        'success': False, 
                        'error': f'Stock insuficiente: {producto.nombre if producto else "Producto"}'
                    })
                
                # ðŸŽ ACTUALIZAR STOCK PANADERÃA (SE DESCUENTA NORMALMENTE TAMBIÃ‰N EN DONACIONES)
                producto.stock_actual -= cantidad
                
                # ðŸŽ PRECIO UNITARIO: para donaciones registramos el precio real pero total=0
                precio_unitario = producto.precio_venta
                
                # Crear detalle de venta
                detalle = DetalleVenta(
                    venta_id=nueva_venta.id,
                    producto_id=producto_id,
                    producto_externo_id=None,
                    cantidad=cantidad,
                    precio_unitario=precio_unitario  # ðŸŽ Registramos el precio real
                )
                detalles_venta.append(detalle)
        
        # Agregar todos los detalles
        for detalle in detalles_venta:
            db.session.add(detalle)
        
        # ðŸ†• MODIFICAR: CREAR FACTURA O RECIBO SEGÃšN CONFIGURACIÃ“N
        if tipo_documento == 'ELECTRONICA':
            # Para factura electrÃ³nica
            numero_factura = f"FE{datetime.now().strftime('%Y%m%d')}{nueva_venta.id:04d}"
            mensaje_exito = f'Factura electrÃ³nica #{numero_factura} generada'
            
            # ðŸŽ MENSAJE ESPECIAL PARA DONACIONES ELECTRÃ“NICAS
            if es_donacion:
                mensaje_exito = f'DonaciÃ³n registrada - Factura electrÃ³nica #{numero_factura}'
        else:
            # Para recibo POS
            numero_factura = f"POS{consecutivo_pos:06d}"  # Formato POS000001
            mensaje_exito = f'Recibo POS #{consecutivo_pos} generado correctamente'
            
            # ðŸŽ MENSAJE ESPECIAL PARA DONACIONES POS
            if es_donacion:
                mensaje_exito = f'DonaciÃ³n registrada - Comprobante POS #{consecutivo_pos}'
        
        factura = Factura(
            venta_id=nueva_venta.id,
            numero_factura=numero_factura,
            subtotal=total_venta,  # ðŸŽ SerÃ¡ 0 para donaciones
            iva=0,
            total=total_venta  # ðŸŽ SerÃ¡ 0 para donaciones
        )
        
        db.session.add(factura)
        db.session.commit()
        
        # ðŸ†• PREPARAR RESPUESTA CON INFORMACIÃ“N COMPLETA
        respuesta = {
            'success': True,
            'venta_id': nueva_venta.id,
            'factura_id': factura.id,
            'numero_factura': factura.numero_factura,
            'consecutivo_pos': consecutivo_pos,
            'tipo_documento': tipo_documento,
            'total': total_venta,
            'mensaje': mensaje_exito,
            # ðŸŽ NUEVO: INCLUIR INFORMACIÃ“N DE DONACIÃ“N EN LA RESPUESTA
            'es_donacion': es_donacion,
            'motivo_donacion': motivo_donacion
        }
        
        print(f"âœ… Venta creada con panaderia_id: {nueva_venta.panaderia_id}")
        
        # ðŸ†• AGREGAR INFORMACIÃ“N DEL CLIENTE SI EXISTE
        if cliente_id:
            cliente = Cliente.query.get(cliente_id)
            if cliente:
                respuesta['cliente'] = cliente.to_dict()
                print(f'âœ… Cliente incluido en respuesta: {cliente.nombre}')
        
        # ðŸ†• LIMPIAR CARRITO DESPUÃ‰S DE VENTA EXITOSA
        if 'carrito' in session:
            session.pop('carrito')
            session.modified = True
        
        # ðŸŽ LOG ESPECIAL PARA DONACIONES
        if es_donacion:
            print(f'ðŸŽ DONACIÃ“N REGISTRADA EXITOSAMENTE - ID: {nueva_venta.id}, Productos: {len(carrito)}, Motivo: {motivo_donacion}')
        else:
            print(f'âœ… Venta registrada exitosamente - ID: {nueva_venta.id}, Tipo: {tipo_documento}, Cliente: {cliente_id}, Total: ${total_venta}')
        
        return jsonify(respuesta)
        
    except Exception as e:
        db.session.rollback()
        print(f"âŒ Error al registrar venta: {e}")
        return jsonify({'success': False, 'error': str(e)})
    
# =============================================
# ðŸ†• RUTAS API PARA GESTIÃ“N DE CLIENTES
# =============================================

@app.route('/api/guardar-cliente', methods=['POST'])
@login_required
@modulo_requerido('clientes')
def guardar_cliente():
    """
    Guarda o actualiza un cliente para facturaciÃ³n electrÃ³nica
    """
    try:
        data = request.get_json()
        print('ðŸ“ Datos del cliente recibidos:', data)
        
        # âœ… VALIDAR DATOS OBLIGATORIOS
        if not data.get('documento') or not data.get('nombre'):
            return jsonify({
                'success': False,
                'error': 'Documento y nombre son obligatorios'
            }), 400
        
        # âœ… BUSCAR CLIENTE EXISTENTE POR DOCUMENTO
        cliente_existente = Cliente.query.filter_by(documento=data['documento']).first()
        
        if cliente_existente:
            # âœ… ACTUALIZAR CLIENTE EXISTENTE
            cliente_existente.nombre = data['nombre']
            cliente_existente.tipo_documento = data.get('tipo_documento', '31')
            cliente_existente.tipo_persona = data.get('tipo_persona', 'J')
            cliente_existente.direccion = data.get('direccion', '')
            cliente_existente.telefono = data.get('telefono', '')
            cliente_existente.email = data.get('email', '')
            cliente_existente.ciudad = data.get('ciudad', '')
            cliente_existente.departamento = data.get('departamento', '')
            cliente_existente.regimen = data.get('regimen', '')
            cliente_existente.responsabilidades = data.get('responsabilidades', '')
            cliente_existente.fecha_actualizacion = datetime.utcnow()
            
            cliente = cliente_existente
            accion = 'actualizado'
            
        else:
            # âœ… CREAR NUEVO CLIENTE
            cliente = Cliente(
                documento=data['documento'],
                nombre=data['nombre'],
                tipo_documento=data.get('tipo_documento', '31'),
                tipo_persona=data.get('tipo_persona', 'J'),
                direccion=data.get('direccion', ''),
                telefono=data.get('telefono', ''),
                email=data.get('email', ''),
                ciudad=data.get('ciudad', ''),
                departamento=data.get('departamento', ''),
                regimen=data.get('regimen', ''),
                responsabilidades=data.get('responsabilidades', ''),
                activo=True
            )
            db.session.add(cliente)
            accion = 'creado'
        
        db.session.commit()
        
        print(f'âœ… Cliente {accion} exitosamente:', cliente.id)
        
        return jsonify({
            'success': True,
            'cliente': cliente.to_dict(),
            'mensaje': f'Cliente {accion} correctamente'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f'âŒ Error guardando cliente: {str(e)}')
        return jsonify({
            'success': False,
            'error': f'Error al guardar cliente: {str(e)}'
        }), 500

@app.route('/api/clientes-recientes', methods=['GET'])
@login_required
@modulo_requerido('clientes')
def obtener_clientes_recientes():
    """
    Obtiene la lista de clientes recientes para selecciÃ³n rÃ¡pida
    """
    try:
        # âœ… OBTENER LOS ÃšLTIMOS 10 CLIENTES ACTIVOS
        clientes = Cliente.query.filter_by(activo=True)\
                               .order_by(Cliente.fecha_actualizacion.desc())\
                               .limit(10)\
                               .all()
        
        clientes_data = [cliente.to_dict() for cliente in clientes]
        
        print(f'âœ… Clientes recientes encontrados: {len(clientes_data)}')
        
        return jsonify(clientes_data)
        
    except Exception as e:
        print(f'âŒ Error obteniendo clientes recientes: {str(e)}')
        return jsonify([])

@app.route('/api/buscar-cliente/<string:documento>', methods=['GET'])
@login_required
@modulo_requerido('clientes')
def buscar_cliente(documento):
    """
    Busca un cliente por nÃºmero de documento
    """
    try:
        cliente = Cliente.query.filter_by(documento=documento, activo=True).first()
        
        if cliente:
            return jsonify({
                'success': True,
                'cliente': cliente.to_dict()
            })
        else:
            return jsonify({
                'success': False,
                'mensaje': 'Cliente no encontrado'
            })
            
    except Exception as e:
        print(f'âŒ Error buscando cliente: {str(e)}')
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/configuracion-sistema', methods=['GET'])
@login_required
@modulo_requerido('configuracion')
def obtener_configuracion_sistema_api():
    """
    API para obtener la configuraciÃ³n del sistema (usada por JavaScript)
    """
    try:
        config = obtener_configuracion_sistema()
        
        return jsonify({
            'tipo_facturacion': config.tipo_facturacion,
            'nombre_empresa': config.nombre_empresa,
            'nit_empresa': config.nit_empresa
        })
        
    except Exception as e:
        print(f'âŒ Error obteniendo configuraciÃ³n: {str(e)}')
        return jsonify({
            'tipo_facturacion': 'POS',
            'nombre_empresa': 'Mi Empresa',
            'nit_empresa': '000000000'
        })

# âœ… FUNCIÃ“N AUXILIAR INDEPENDIENTE
def obtener_texto_legal(tipo_documento):
    """
    Retorna el texto legal apropiado segÃºn el tipo de documento
    """
    if tipo_documento == 'ELECTRONICA':
        return "Factura electrÃ³nica de venta - RÃ©gimen simplificado"
    else:
        return "Documento equivalente POS â€“ No vÃ¡lido como factura electrÃ³nica de venta"

# =============================================
# FIN RUTAS API CLIENTES
# =============================================

@app.route('/configuracion/facturacion', methods=['GET', 'POST'])
@login_required
@modulo_requerido('configuracion')
def configuracion_facturacion():
    """
    ConfiguraciÃ³n del tipo de facturaciÃ³n (POS vs ElectrÃ³nica)
    """
    config = obtener_configuracion_sistema()
    
    if request.method == 'POST':
        try:
            # Actualizar configuraciÃ³n
            config.tipo_facturacion = request.form.get('tipo_facturacion', 'POS')
            config.nombre_empresa = request.form.get('nombre_empresa', '')
            config.nit_empresa = request.form.get('nit_empresa', '')
            config.direccion_empresa = request.form.get('direccion_empresa', '')
            config.telefono_empresa = request.form.get('telefono_empresa', '')
            config.ciudad_empresa = request.form.get('ciudad_empresa', '')
            config.regimen_empresa = request.form.get('regimen_empresa', 'Simplificado')
            
            db.session.commit()
            flash('âœ… ConfiguraciÃ³n actualizada correctamente', 'success')
            
        except Exception as e:
            flash(f'âŒ Error actualizando configuraciÃ³n: {str(e)}', 'error')
    
    return render_template('configuracion_facturacion.html', config=config)

@app.route('/api/exportar-xml/<int:venta_id>')
@login_required
@modulo_requerido('punto_venta')
def exportar_xml_venta(venta_id):
    """
    Exporta una venta a formato XML UBL 2.1 - VERSIÃ“N CORREGIDA
    """
    try:
        venta = Venta.query.get_or_404(venta_id)
        detalles = DetalleVenta.query.filter_by(venta_id=venta_id).all()
        
        # Verificar que existan detalles
        if not detalles:
            flash('âŒ No hay detalles de venta para generar el XML', 'error')
            return redirect(request.referrer or url_for('ventas'))
        
        # Obtener configuraciÃ³n del sistema
        config = obtener_configuracion_sistema()
        
        # Generar XML
        xml_content = generar_xml_ubl_21(venta, config, detalles)
        
        if not xml_content:
            flash('âŒ No se pudo generar el contenido XML', 'error')
            return redirect(request.referrer or url_for('ventas'))
        
        # ðŸ†• CREAR RESPUESTA CON HEADERS CORRECTOS PARA XML
        response = make_response(xml_content)
        response.headers['Content-Type'] = 'application/xml; charset=utf-8'
        response.headers['Content-Disposition'] = f'attachment; filename="Factura_{venta_id}_{venta.fecha_hora.strftime("%Y%m%d_%H%M%S")}.xml"'
        
        # ðŸ†• EVITAR QUE EL NAVEGADOR INTERPRETE COMO HTML
        response.headers['X-Content-Type-Options'] = 'nosniff'
        
        return response
        
    except Exception as e:
        flash(f'âŒ Error generando XML: {str(e)}', 'error')
        return redirect(request.referrer or url_for('ventas'))

# FunciÃ³n temporal para debug del XML
@app.route('/api/debug-xml/<int:venta_id>')
@login_required
@modulo_requerido('punto_venta')
def debug_xml(venta_id):
    """Debug del XML generado"""
    try:
        venta = Venta.query.get_or_404(venta_id)
        detalles = DetalleVenta.query.filter_by(venta_id=venta_id).all()
        config = obtener_configuracion_sistema()
        
        xml_content = generar_xml_ubl_21(venta, config, detalles)
        
        # Verificar si el XML es vÃ¡lido
        try:
            import xml.etree.ElementTree as ET
            ET.fromstring(xml_content)
            xml_valid = "âœ… XML VÃLIDO"
        except Exception as e:
            xml_valid = f"âŒ XML INVÃLIDO: {str(e)}"
        
        return f"""
        <h1>Debug XML - Venta {venta_id}</h1>
        <p>{xml_valid}</p>
        <h3>Contenido XML:</h3>
        <pre>{xml_content}</pre>
        <h3>Headers que deberÃ­a tener:</h3>
        <ul>
            <li>Content-Type: application/xml; charset=utf-8</li>
            <li>Content-Disposition: attachment; filename=...</li>
        </ul>
        """
    except Exception as e:
        return f"Error en debug: {str(e)}"
    
@app.route('/api/imprimir-factura/<int:venta_id>')
@login_required
@modulo_requerido('punto_venta')
def imprimir_factura_electronica(venta_id):
    """Genera la representaciÃ³n impresa de la factura electrÃ³nica"""
    try:
        venta = Venta.query.get_or_404(venta_id)
        detalles = DetalleVenta.query.filter_by(venta_id=venta_id).all()
        config = obtener_configuracion_sistema()
        
        # ðŸ†• DEBUG: Verificar datos del cliente
        print(f"ðŸ” DEBUG Factura ElectrÃ³nica - Venta ID: {venta_id}")
        print(f"ðŸ” DEBUG Cliente ID: {venta.cliente_id}")
        if venta.cliente:
            print(f"ðŸ” DEBUG Datos Cliente: {venta.cliente.nombre}, {venta.cliente.documento}")
        else:
            print("ðŸ” DEBUG: No hay cliente asociado a esta venta")
        
        # Verificar si es factura electrÃ³nica
        if venta.tipo_documento != 'ELECTRONICA':
            flash('âš ï¸ Esta venta no es una factura electrÃ³nica', 'warning')
            return redirect(request.referrer or url_for('ventas'))
        
        return render_template(
            'factura_electronica.html',
            venta=venta,
            detalles=detalles,
            config=config,
            ahora=datetime.utcnow()
        )
        
    except Exception as e:
        flash(f'âŒ Error generando factura: {str(e)}', 'error')
        return redirect(request.referrer or url_for('ventas'))
    
@app.route('/recibo-pos/<int:venta_id>')
@login_required
@modulo_requerido('punto_venta')
def recibo_pos(venta_id):
    """
    ðŸ†• Genera el recibo POS para impresiÃ³n tÃ©rmica
    """
    try:
        venta = Venta.query.get_or_404(venta_id)
        detalles = DetalleVenta.query.filter_by(venta_id=venta_id).all()
        config = obtener_configuracion_sistema()
        
        return render_template('recibo_pos.html', 
                             venta=venta, 
                             detalles=detalles, 
                             config=config)
                             
    except Exception as e:
        flash(f'Error al generar recibo: {str(e)}', 'error')
        return redirect(url_for('punto_venta'))
    
@app.route('/agregar_al_carrito', methods=['POST'])
@login_required
@modulo_requerido('punto_venta')
def agregar_al_carrito():
    try:
        data = request.get_json()
        producto_id = data['producto_id']
        cantidad = data['cantidad']
        
        # Validar que la cantidad sea positiva
        if cantidad <= 0:
            return jsonify({'success': False, 'message': 'La cantidad debe ser mayor a 0'})
        
        # Inicializar carrito en sesiÃ³n si no existe
        if 'carrito' not in session:
            session['carrito'] = {}
        
        # Convertir a string porque las claves de session deben ser strings
        producto_id_str = str(producto_id)
        
        # Agregar o actualizar producto en carrito
        carrito = session['carrito']
        if producto_id_str in carrito:
            carrito[producto_id_str] += cantidad
        else:
            carrito[producto_id_str] = cantidad
        
        session['carrito'] = carrito
        session.modified = True
        
        print(f"Carrito actualizado: {session['carrito']}")  # Para debug
        
        return jsonify({
            'success': True, 
            'message': f'Producto agregado al carrito ({cantidad} unidades)',
            'carrito': session['carrito']
        })
    
    except Exception as e:
        print(f"Error: {e}")  # Para debug
        return jsonify({'success': False, 'message': 'Error interno del servidor'})

# Ruta para cerrar sesiÃ³n
@app.route('/logout')
def logout():
    session.clear()
    flash('Has cerrado sesiÃ³n', 'info')
    return redirect(url_for('login'))

# =============================================
# RUTAS DE PROVEEDORES
# =============================================

@app.route('/proveedores')
@login_required
@modulo_requerido('proveedores')
def proveedores():
    panaderia_actual = session.get('panaderia_id', 1)
    panaderia_actual = session.get('panaderia_id', 1)
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    todos_proveedores = Proveedor.query.filter_by(panaderia_id=panaderia_actual).all()
    return render_template('proveedores.html', proveedores=todos_proveedores)

    panaderia_actual = session.get('panaderia_id', 1)
@app.route('/agregar_proveedor', methods=['GET', 'POST'])
@login_required
@modulo_requerido('proveedores')
def agregar_proveedor():
    panaderia_actual = session.get('panaderia_id', 1)
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    if request.method == 'POST':
        try:
            nuevo_proveedor = Proveedor(panaderia_id=panaderia_actual, 
                nombre=request.form['nombre'],
                contacto=request.form.get('contacto', ''),
                telefono=request.form.get('telefono', ''),
                email=request.form.get('email', ''),
                direccion=request.form.get('direccion', ''),
                productos_que_suministra=request.form.get('productos_que_suministra', ''),
                tiempo_entrega_dias=int(request.form.get('tiempo_entrega_dias', 1)),
                evaluacion=int(request.form.get('evaluacion', 5)),
                activo=True
            )
            
            db.session.add(nuevo_proveedor)
            db.session.commit()
            
            flash(f'Proveedor "{nuevo_proveedor.nombre}" agregado correctamente', 'success')
            return redirect(url_for('proveedores'))
            
        except Exception as e:
            flash('Error al agregar el proveedor', 'error')
            return redirect(url_for('agregar_proveedor'))
    
    return render_template('agregar_proveedor.html')

@app.route('/editar_proveedor/<int:id>', methods=['GET', 'POST'])
@login_required
@modulo_requerido('proveedores')
def editar_proveedor(id):
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    proveedor = Proveedor.query.filter_by(panaderia_id=panaderia_actual, id=id).first_or_404()
    
    if request.method == 'POST':
        try:
            proveedor.nombre = request.form['nombre']
            proveedor.contacto = request.form.get('contacto', '')
            proveedor.telefono = request.form.get('telefono', '')
            proveedor.email = request.form.get('email', '')
            proveedor.direccion = request.form.get('direccion', '')
            proveedor.productos_que_suministra = request.form.get('productos_que_suministra', '')
            proveedor.tiempo_entrega_dias = int(request.form.get('tiempo_entrega_dias', 1))
            proveedor.evaluacion = int(request.form.get('evaluacion', 5))
            
            db.session.commit()
            flash(f'Proveedor "{proveedor.nombre}" actualizado correctamente', 'success')
            return redirect(url_for('proveedores'))
            
        except Exception as e:
            flash('Error al actualizar el proveedor', 'error')
            return redirect(url_for('editar_proveedor', id=id))
    
    return render_template('editar_proveedor.html', proveedor=proveedor)

    panaderia_actual = session.get('panaderia_id', 1)
@app.route('/toggle_proveedor/<int:id>')
@login_required
@modulo_requerido('proveedores')
def toggle_proveedor(id):
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    proveedor = Proveedor.query.filter_by(panaderia_id=panaderia_actual, id=id).first_or_404()
    proveedor.activo = not proveedor.activo
    db.session.commit()
    
    estado = "activado" if proveedor.activo else "desactivado"
    flash(f'Proveedor "{proveedor.nombre}" {estado} correctamente', 'success')
    return redirect(url_for('proveedores'))


# =============================================
# RUTAS DE PRODUCTOS EXTERNOS
# =============================================

    panaderia_actual = session.get('panaderia_id', 1)
@app.route('/productos_externos')
@login_required
@modulo_requerido('productos')
def productos_externos():
    """GestiÃ³n de productos externos (bebidas, helados) - SOLO de esta panaderÃ­a"""
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    # FILTRO CLAVE: Solo productos de ESTA panaderÃ­a
    panaderia_actual = obtener_panaderia_actual()  # â† ÃšNICO CAMBIO AQUÃ
    productos = ProductoExterno.query.filter_by(
        activo=True, 
        panaderia_id=panaderia_actual  # â† ESTA LÃNEA ES LA CLAVE
    ).all()
    
    proveedores = Proveedor.query.filter_by(panaderia_id=1, activo=True).all()
    
    # Calcular mÃ©tricas adicionales para cada producto
    for producto in productos:
        producto.utilidad_unitaria = producto.precio_venta - producto.precio_compra
        producto.margen_ganancia = (producto.utilidad_unitaria / producto.precio_compra * 100) if producto.precio_compra > 0 else 0
    
    return render_template('productos_externos.html', 
                         productos=productos, 
                         proveedores=proveedores)
    
# RUTA PARA CREAR PRODUCTO EXTERNO
@app.route('/crear_producto_externo', methods=['POST'])
@login_required
@modulo_requerido('productos')
def crear_producto_externo():
    """Crear nuevo producto externo - Asigna automÃ¡ticamente la panaderÃ­a actual"""
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    try:
        panaderia_actual = session.get('panaderia_id', 1)
        
        nuevo_producto = ProductoExterno(
            nombre=request.form['nombre'],
            descripcion=request.form.get('descripcion', ''),
            categoria=request.form['categoria'],
            marca=request.form.get('marca', ''),
            codigo_barras=request.form.get('codigo_barras', ''),
            proveedor_id=request.form.get('proveedor_id'),
            precio_compra=float(request.form['precio_compra']),
            precio_venta=float(request.form['precio_venta']),
            stock_actual=int(request.form.get('stock_actual', 0)),
            stock_minimo=int(request.form.get('stock_minimo', 5)),
            panaderia_id=panaderia_actual  # â† ASIGNACIÃ“N AUTOMÃTICA
        )
        
        db.session.add(nuevo_producto)
        db.session.commit()
        
        flash('âœ… Producto externo creado exitosamente', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'âŒ Error al crear producto: {str(e)}', 'error')
    
    return redirect(url_for('productos_externos'))

# RUTA PARA EDITAR PRODUCTO EXTERNO
@app.route('/editar_producto_externo/<int:id>', methods=['POST'])
@login_required
@modulo_requerido('productos')
def editar_producto_externo(id):
    """Editar producto externo - Solo si pertenece a esta panaderÃ­a"""
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    try:
        panaderia_actual = session.get('panaderia_id', 1)
        
        # FILTRO DE SEGURIDAD: Solo productos de esta panaderÃ­a
        producto = ProductoExterno.query.filter_by(
            id=id, 
            panaderia_id=panaderia_actual  # â† PROTECCIÃ“N
        ).first()
        
        if not producto:
            flash('âŒ Producto no encontrado o no tienes permisos', 'error')
            return redirect(url_for('productos_externos'))
        
        # Actualizar campos
        producto.nombre = request.form['nombre']
        producto.descripcion = request.form.get('descripcion', '')
        producto.categoria = request.form['categoria']
        producto.marca = request.form.get('marca', '')
        producto.codigo_barras = request.form.get('codigo_barras', '')
        producto.proveedor_id = request.form.get('proveedor_id')
        producto.precio_compra = float(request.form['precio_compra'])
        producto.precio_venta = float(request.form['precio_venta'])
        producto.stock_actual = int(request.form.get('stock_actual', 0))
        producto.stock_minimo = int(request.form.get('stock_minimo', 5))
        
        db.session.commit()
        flash('âœ… Producto actualizado exitosamente', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'âŒ Error al actualizar producto: {str(e)}', 'error')
    
    return redirect(url_for('productos_externos'))

# RUTA PARA ELIMINAR PRODUCTO EXTERNO (Borrado lÃ³gico)
@app.route('/eliminar_producto_externo/<int:id>', methods=['POST'])
@login_required
@modulo_requerido('productos')
def eliminar_producto_externo(id):
    """Eliminar producto externo (borrado lÃ³gico) - Solo si pertenece a esta panaderÃ­a"""
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    try:
        panaderia_actual = session.get('panaderia_id', 1)
        
        # FILTRO DE SEGURIDAD: Solo productos de esta panaderÃ­a
        producto = ProductoExterno.query.filter_by(
            id=id, 
            panaderia_id=panaderia_actual  # â† PROTECCIÃ“N
        ).first()
        
        if not producto:
            flash('âŒ Producto no encontrado o no tienes permisos', 'error')
            return redirect(url_for('productos_externos'))
        
        # Borrado lÃ³gico (mejor que eliminar fÃ­sicamente)
        producto.activo = False
        db.session.commit()
        
        flash('âœ… Producto eliminado exitosamente', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'âŒ Error al eliminar producto: {str(e)}', 'error')
    
    return redirect(url_for('productos_externos'))

@app.route('/registrar_compra_externa', methods=['POST'])
@login_required
@modulo_requerido('productos')
def registrar_compra_externa():
    """Registrar compra de productos externos y actualizar stock"""
    if 'user_id' not in session:
        return jsonify({'success': False, 'message': 'No autorizado'})
    
    try:
        producto_id = request.form['producto_id']
        proveedor_id = request.form['proveedor_id']
        cantidad = int(request.form['cantidad'])
        precio_compra = float(request.form['precio_compra'])
        notas = request.form.get('notas', '')
        
        producto = ProductoExterno.query.get(producto_id)
        if not producto:
            return jsonify({'success': False, 'message': 'Producto no encontrado'})
        
        # Registrar la compra
        compra = CompraExterna(
            producto_id=producto_id,
            proveedor_id=proveedor_id,
            cantidad=cantidad,
            precio_compra=precio_compra,
            total_compra=cantidad * precio_compra,
            notas=notas
        )
        
        # Actualizar stock y precios del producto
        producto.stock_actual += cantidad
        producto.precio_compra = precio_compra  # Actualizar Ãºltimo precio de compra
        producto.fecha_ultima_compra = datetime.utcnow()
        
        db.session.add(compra)
        db.session.commit()
        
        return jsonify({
            'success': True, 
            'message': f'Compra registrada: {cantidad} unidades de {producto.nombre}'
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'message': f'Error: {str(e)}'})

    
    # Obtener todas las materias primas (activas e inactivas)
    materias = MateriaPrima.query.all()
    
    # CALCULAR FECHAS PARA ALERTAS DE VENCIMIENTO
    hoy = datetime.now().date()
    hoy_mas_15 = hoy + timedelta(days=15)
    
    return render_template('materias_primas.html', 
                         materias_primas=materias,
                         hoy=hoy,
                         hoy_mas_15=hoy_mas_15)
    
@app.route('/materias_primas')
@login_required
@modulo_requerido('inventario')
def materias_primas():
    """GestiÃ³n de materias primas - SOLO de esta panaderÃ­a"""
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    # FILTRO CLAVE: Solo materias primas de ESTA panaderÃ­a (CON ACCESO REMOTO)
    panaderia_actual = obtener_panaderia_actual()  # â† ÃšNICO CAMBIO EN FILTRO
    materias = MateriaPrima.query.filter_by(
        activo=True, 
        panaderia_id=panaderia_actual
    ).all()
    
    proveedores = Proveedor.query.filter_by(panaderia_id=1, activo=True).all()
    
    # âœ… AGREGAR FECHAS PARA EL TEMPLATE (SOLO EN ESTA RUTA)
    hoy = datetime.now().date()
    hoy_mas_15 = hoy + timedelta(days=15)
    
    return render_template('materias_primas.html', 
                         materias_primas=materias,  # â† nombre que usa el template
                         proveedores=proveedores,
                         hoy=hoy,                   # â† AGREGAR
                         hoy_mas_15=hoy_mas_15)     # â† AGREGAR

@app.route('/agregar_materia_prima', methods=['GET', 'POST'])
@login_required
@modulo_requerido('inventario')
def agregar_materia_prima():
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    panaderia_actual = session.get('panaderia_id', 1)
    proveedores = Proveedor.query.filter_by(panaderia_id=1, activo=True).all()
    
    
    
    if request.method == 'POST':
        try:
            nombre = request.form['nombre']
            proveedor_id = request.form.get('proveedor_id', type=int)
            unidad_medida = request.form['unidad_medida']
            stock_minimo = float(request.form.get('stock_minimo', 0))
            
            # NUEVOS CAMPOS CONFIGURACIÃ“N EMPAQUES
            unidad_compra = request.form['unidad_compra']
            gramos_por_empaque = float(request.form['gramos_por_empaque'])
            stock_minimo_empaques = int(request.form['stock_minimo_empaques'])
            
            # NUEVOS CAMPOS COMPRA INICIAL
            cantidad_empaques_comprados = int(request.form['cantidad_empaques_comprados'])
            precio_total_compra = float(request.form['precio_total_compra'])
            
            # VALIDACIONES
            if not proveedor_id:
                flash('Debe seleccionar un proveedor', 'error')
                return redirect(url_for('agregar_materia_prima'))
                
            if gramos_por_empaque <= 0:
                flash('El peso por empaque debe ser mayor a 0', 'error')
                return redirect(url_for('agregar_materia_prima'))
                
            if stock_minimo_empaques < 1:
                flash('El stock mÃ­nimo de empaques debe ser al menos 1', 'error')
                return redirect(url_for('agregar_materia_prima'))
            
            if cantidad_empaques_comprados < 1:
                flash('La cantidad de empaques debe ser al menos 1', 'error')
                return redirect(url_for('agregar_materia_prima'))
                
            if precio_total_compra <= 0:
                flash('El precio total debe ser mayor a 0', 'error')
                return redirect(url_for('agregar_materia_prima'))
            
            # CALCULAR STOCK INICIAL Y COSTOS
            stock_inicial = cantidad_empaques_comprados * gramos_por_empaque
            costo_unitario = precio_total_compra / stock_inicial
            precio_unitario_empaque = precio_total_compra / cantidad_empaques_comprados
            
            # Crear materia prima
            nueva_materia = MateriaPrima(
                nombre=nombre,
                proveedor_id=proveedor_id,
                unidad_medida=unidad_medida,
                costo_promedio=costo_unitario,
                stock_actual=stock_inicial,
                stock_minimo=stock_minimo,
                unidad_compra=unidad_compra,
                gramos_por_empaque=gramos_por_empaque,
                stock_minimo_empaques=stock_minimo_empaques,
                panaderia_id=panaderia_actual,
                activo=True
            )
            
            db.session.add(nueva_materia)
            db.session.flush()  # Para obtener el ID
            
            # REGISTRAR COMPRA INICIAL EN HISTORIAL
            nueva_compra = HistorialCompra(
                materia_prima_id=nueva_materia.id,
                cantidad_empaques=cantidad_empaques_comprados,
                precio_total=precio_total_compra,
                precio_unitario_empaque=precio_unitario_empaque,
                usuario_id=session['user_id']
            )
            db.session.add(nueva_compra)
            db.session.commit()
            
            flash(f'Materia prima "{nombre}" agregada con {stock_inicial} {unidad_medida} de stock inicial', 'success')
            return redirect(url_for('materias_primas'))
            
        except ValueError as e:
            flash('Error: Los campos numÃ©ricos deben contener valores vÃ¡lidos', 'error')
            return redirect(url_for('agregar_materia_prima'))
        except Exception as e:
            flash(f'Error inesperado al agregar la materia prima: {str(e)}', 'error')
            return redirect(url_for('agregar_materia_prima'))
    
    return render_template('agregar_materia_prima.html', proveedores=proveedores)

@app.route('/editar_materia_prima/<int:id>', methods=['GET', 'POST'])
@login_required
@modulo_requerido('inventario')
def editar_materia_prima(id):
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    panaderia_actual = session.get('panaderia_id', 1)
    materia = MateriaPrima.query.get_or_404(id)
    proveedores = Proveedor.query.filter_by(panaderia_id=1, activo=True).all()
    
    if request.method == 'POST':
        try:
            # VERIFICAR SI ES UNA NUEVA COMPRA
            if 'nueva_compra_cantidad' in request.form and request.form['nueva_compra_cantidad']:
                cantidad_empaques = int(request.form['nueva_compra_cantidad'])
                precio_total = float(request.form['nueva_compra_precio'])
                
                               
                if cantidad_empaques <= 0 or precio_total <= 0:
                    flash('Cantidad y precio deben ser mayores a 0', 'error')
                    return redirect(url_for('editar_materia_prima', id=id))
                
                # CALCULAR NUEVO STOCK Y COSTO PROMEDIO
                nuevo_stock_gramos = cantidad_empaques * materia.gramos_por_empaque
                precio_unitario_empaque = precio_total / cantidad_empaques
                
                # CALCULAR NUEVO COSTO PROMEDIO PONDERADO
                stock_actual_valor = materia.stock_actual * materia.costo_promedio
                nuevo_stock_valor = nuevo_stock_gramos * (precio_total / nuevo_stock_gramos)
                total_stock = materia.stock_actual + nuevo_stock_gramos
                
                if total_stock > 0:
                    nuevo_costo_promedio = (stock_actual_valor + nuevo_stock_valor) / total_stock
                else:
                    nuevo_costo_promedio = precio_total / nuevo_stock_gramos
                
                # ACTUALIZAR MATERIA PRIMA
                materia.stock_actual += nuevo_stock_gramos
                materia.costo_promedio = nuevo_costo_promedio
                materia.fecha_ultima_actualizacion = datetime.utcnow()
                
                # REGISTRAR EN HISTORIAL
                nueva_compra = HistorialCompra(
                    materia_prima_id=materia.id,
                    cantidad_empaques=cantidad_empaques,
                    precio_total=precio_total,
                    precio_unitario_empaque=precio_unitario_empaque,
                    usuario_id=session['user_id']
                )
                db.session.add(nueva_compra)
                
                flash(f'âœ… Se agregaron {nuevo_stock_gramos} {materia.unidad_medida} al stock', 'success')
            
            # ACTUALIZAR DATOS BÃSICOS
            materia.nombre = request.form['nombre']
            materia.proveedor_id = request.form.get('proveedor_id', type=int)
            materia.unidad_medida = request.form['unidad_medida']
            materia.stock_minimo = float(request.form.get('stock_minimo', 0))
            materia.stock_minimo_empaques = int(request.form.get('stock_minimo_empaques', 1))
            materia.gramos_por_empaque = float(request.form.get('gramos_por_empaque', 1.0))
            materia.unidad_compra = request.form.get('unidad_compra', 'Unidad')
            
            # MANEJAR FECHA DE VENCIMIENTO
            fecha_vencimiento_str = request.form.get('fecha_vencimiento', '').strip()
            if fecha_vencimiento_str:
                materia.fecha_vencimiento = datetime.strptime(fecha_vencimiento_str, '%Y-%m-%d').date()
            else:
                materia.fecha_vencimiento = None
            
            # VALIDACIONES
            if not materia.proveedor_id:
                flash('Debe seleccionar un proveedor', 'error')
                return redirect(url_for('editar_materia_prima', id=id))
                
            if materia.stock_minimo < 0:
                flash('El stock mÃ­nimo no puede ser negativo', 'error')
                return redirect(url_for('editar_materia_prima', id=id))
            
            db.session.commit()
            flash(f'Materia prima "{materia.nombre}" actualizada correctamente', 'success')
            return redirect(url_for('materias_primas'))
            
        except ValueError as e:
            flash('Error: Los campos numÃ©ricos deben contener valores vÃ¡lidos', 'error')
            return redirect(url_for('editar_materia_prima', id=id))
        except Exception as e:
            flash(f'Error inesperado al actualizar la materia prima: {str(e)}', 'error')
            return redirect(url_for('editar_materia_prima', id=id))
    
    # OBTENER HISTORIAL DE COMPRAS PARA MOSTRAR
    historial_compras = HistorialCompra.query.filter_by(materia_prima_id=id).order_by(HistorialCompra.fecha_compra.desc()).all()
    
    return render_template('editar_materia_prima.html', 
                         materia=materia, 
                         proveedores=proveedores,
                         historial_compras=historial_compras)

@app.route('/desactivar_materia_prima/<int:id>')
@login_required
@modulo_requerido('inventario')
def desactivar_materia_prima(id):
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    materia = MateriaPrima.query.get_or_404(id)
    materia.activo = False
    db.session.commit()
    
    flash(f'Materia prima "{materia.nombre}" desactivada correctamente', 'success')
    return redirect(url_for('materias_primas'))

@app.route('/activar_materia_prima/<int:id>')
@login_required
@modulo_requerido('inventario')
def activar_materia_prima(id):
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    materia = MateriaPrima.query.get_or_404(id)
    materia.activo = True
    db.session.commit()
    
    flash(f'Materia prima "{materia.nombre}" activada correctamente', 'success')
    return redirect(url_for('materias_primas'))

# NUEVA RUTA PARA VER HISTORIAL DE COMPRAS
@app.route('/historial_compras/<int:materia_prima_id>')
@login_required
@modulo_requerido('inventario')
def historial_compras(materia_prima_id):
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    materia = MateriaPrima.query.get_or_404(materia_prima_id)
    historial = HistorialCompra.query.filter_by(materia_prima_id=materia_prima_id).order_by(HistorialCompra.fecha_compra.desc()).all()
    
    return render_template('historial_compras.html', materia=materia, historial=historial)

# =============================================
# RUTAS DE PRODUCCIÃ“N Y RECETAS - COMPLETAMENTE ACTUALIZADAS CON PRECIOS REALES
# =============================================
@app.route('/recetas')
@login_required
@modulo_requerido('produccion')
def recetas():
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    # âœ… AGREGADO: Filtro multicliente (CON ACCESO REMOTO)
    panaderia_actual = obtener_panaderia_actual()  # â† ÃšNICO CAMBIO EN FILTRO
    print(f"ðŸ” DEBUG RECETAS: PanaderÃ­a actual: {panaderia_actual}")
    
    # âœ… âœ… âœ… NUEVO: BLOQUE SUPER USUARIO (MEJORADO) âœ… âœ… âœ…
    if es_super_usuario() and not session.get('panaderia_remota'):
        flash("ðŸ”§ Como super usuario, usa 'Acceder a esta panaderÃ­a' para ver recetas especÃ­ficas", "info")
        return render_template('recetas.html', recetas=[])
    # âœ… âœ… âœ… FIN BLOQUE SUPER USUARIO âœ… âœ… âœ…
    
    # âœ… CORREGIDO: Solo recetas de ESTA panaderÃ­a
    recetas_panaderia = Receta.query.filter_by(panaderia_id=panaderia_actual, activo=True).all()
    
    print(f"ðŸ” DEBUG RECETAS: Recetas encontradas para panaderÃ­a {panaderia_actual}: {len(recetas_panaderia)}")
    for receta in recetas_panaderia:
        print(f"   - {receta.nombre} (ID: {receta.id})")
    
    return render_template('recetas.html', recetas=recetas_panaderia)

@app.route('/detalle_receta/<int:id>')
@login_required
@modulo_requerido('produccion')
def detalle_receta(id):
    """PÃ¡gina de detalle de una receta especÃ­fica"""
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    receta = Receta.query.get_or_404(id)
    return render_template('detalle_receta.html', receta=receta)

@app.route('/producir_receta/<int:id>', methods=['GET', 'POST'])
@login_required
@modulo_requerido('produccion')
def producir_receta(id):
    """ProducciÃ³n de una receta - cÃ¡lculo de ingredientes"""
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    receta = Receta.query.get_or_404(id)
    
    if request.method == 'POST':
        try:
            cantidad = int(request.form['cantidad'])
            
            # Verificar stock disponible
            ingredientes_insuficientes = []
            for ingrediente in receta.ingredientes:
                cantidad_necesaria = (ingrediente.cantidad_gramos / receta.unidades_obtenidas) * cantidad
                if ingrediente.materia_prima.stock_actual < cantidad_necesaria:
                    ingredientes_insuficientes.append({
                        'nombre': ingrediente.materia_prima.nombre,
                        'necesario': cantidad_necesaria,
                        'disponible': ingrediente.materia_prima.stock_actual,
                        'unidad': ingrediente.materia_prima.unidad_medida
                    })
            
            if ingredientes_insuficientes:
                return render_template('produccion.html', 
                                     receta=receta,
                                     cantidad=cantidad,
                                     ingredientes_insuficientes=ingredientes_insuficientes)
            
            # Crear registro de producciÃ³n
            orden_produccion = OrdenProduccion(
                receta_id=receta.id,
                cantidad_producir=cantidad,
                estado='confirmada',
                usuario_id=session['user_id'],
                fecha_inicio=datetime.utcnow()
            )
            db.session.add(orden_produccion)
            db.session.flush()  # Para obtener el ID
            
            # Descontar ingredientes del inventario y registrar en historial
            for ingrediente in receta.ingredientes:
                cantidad_necesaria = (ingrediente.cantidad_gramos / receta.unidades_obtenidas) * cantidad
                
                # Actualizar stock
                ingrediente.materia_prima.stock_actual -= cantidad_necesaria
                
                # Registrar en historial de inventario
                movimiento = HistorialInventario(
                    materia_prima_id=ingrediente.materia_prima.id,
                    orden_produccion_id=orden_produccion.id,
                    cantidad_utilizada=cantidad_necesaria,
                    tipo_movimiento='produccion'
                )
                db.session.add(movimiento)
            
            db.session.commit()
            flash(f'âœ… ProducciÃ³n de {cantidad} unidades confirmada. Ingredientes descontados del inventario.', 'success')
            return redirect(url_for('recetas'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'âŒ Error al procesar la producciÃ³n: {str(e)}', 'error')
            return redirect(url_for('producir_receta', id=id))
    
    # GET request - mostrar formulario de producciÃ³n
    cantidad = request.args.get('cantidad', receta.unidades_obtenidas, type=int)
    return render_template('produccion.html', receta=receta, cantidad=cantidad)

@app.route('/api/calcular_ingredientes/<int:id>')
@login_required
@modulo_requerido('produccion')
def calcular_ingredientes(id):
    """API para calcular ingredientes necesarios (AJAX)"""
    if 'user_id' not in session:
        return jsonify({'error': 'No autorizado'}), 401
    
    # âœ… AGREGADO: Filtro multicliente
    panaderia_actual = session.get('panaderia_id')
    receta = Receta.query.filter_by(id=id, panaderia_id=panaderia_actual).first()
    
    if not receta:
        return jsonify({'error': 'Receta no encontrada'}), 404
    
    cantidad = request.args.get('cantidad', receta.unidades_obtenidas, type=int)
    
    ingredientes_calculados = []
    for ingrediente in receta.ingredientes:
        cantidad_necesaria = (ingrediente.cantidad_gramos / receta.unidades_obtenidas) * cantidad
        suficiente = ingrediente.materia_prima.stock_actual >= cantidad_necesaria
        
        ingredientes_calculados.append({
            'id': ingrediente.id,
            'nombre': ingrediente.materia_prima.nombre,
            'cantidad_original': ingrediente.cantidad_gramos,
            'cantidad_calculada': round(cantidad_necesaria, 2),
            'unidad': ingrediente.materia_prima.unidad_medida,
            'stock_disponible': ingrediente.materia_prima.stock_actual,
            'suficiente': suficiente
        })
    
    return jsonify(ingredientes_calculados)

# âœ… NUEVA API PARA ACTUALIZAR PRECIO REAL EN TIEMPO REAL
@app.route('/api/actualizar_precio_real/<int:receta_id>', methods=['POST'])
@login_required
@modulo_requerido('produccion')
def actualizar_precio_real(receta_id):
    """API para actualizar el precio real de una receta desde la lista"""
    if 'user_id' not in session:
        return jsonify({'error': 'No autorizado'}), 401
    
    receta = Receta.query.get_or_404(receta_id)
    data = request.get_json()
    nuevo_precio = float(data.get('precio_real', 0))
    
    try:
        receta.precio_venta_real = nuevo_precio
        db.session.commit()
        
        return jsonify({
            'success': True,
            'precio_actualizado': nuevo_precio,
            'utilidad_pesos': receta.utilidad_real_pesos,
            'utilidad_porcentaje': round(receta.utilidad_real_porcentaje, 1),
            'rentabilidad': receta.rentabilidad_categoria,
            'punto_equilibrio': receta.punto_equilibrio_unidades,
            'costo_unitario': receta.costo_unitario
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

# âœ… NUEVO ENDPOINT PARA CÃLCULOS EN TIEMPO REAL DE RECETAS
@app.route('/api/calcular_precio_receta', methods=['POST'])
@login_required
@modulo_requerido('produccion')
def calcular_precio_receta():
    """API para cÃ¡lculos en tiempo real de costos y precios con 45% CIF + 45% Ganancia"""
    if 'user_id' not in session:
        return jsonify({'error': 'No autorizado'}), 401
    
    try:
        data = request.get_json()
        
        # Calcular costo total de ingredientes
        costo_total_mp = 0
        peso_total = 0
        
        for ingrediente in data.get('ingredientes', []):
            materia_prima_id = ingrediente.get('materia_prima_id')
            cantidad_gramos = float(ingrediente.get('cantidad_gramos', 0))
            
            if materia_prima_id and cantidad_gramos > 0:
                materia_prima = MateriaPrima.query.get(materia_prima_id)
                if materia_prima:
                    # Calcular costo del ingrediente
                    costo_ingrediente = cantidad_gramos * materia_prima.costo_promedio
                    costo_total_mp += costo_ingrediente
                    peso_total += cantidad_gramos
        
        # Obtener parÃ¡metros adicionales
        peso_unidad = float(data.get('peso_unidad_gramos', 0))
        porcentaje_perdida = float(data.get('porcentaje_perdida', 10.0))
        
        # Calcular unidades obtenidas considerando pÃ©rdida por horneado
        peso_horneado_total = peso_total * (1 - porcentaje_perdida / 100)

        # Calcular unidades obtenidas
        if peso_unidad > 0:
            unidades_obtenidas = int(peso_horneado_total / peso_unidad)
        else:
            unidades_obtenidas = 0

        # APLICAR FÃ“RMULAS DEL EXCEL: 45% CIF + 45% GANANCIA
        costo_mp = costo_total_mp
        cif = costo_mp * 0.45  # 45% CIF
        costo_total_con_cif = costo_mp + cif
        ganancia = costo_total_con_cif * 0.45  # 45% Ganancia
        precio_total_preparacion = costo_total_con_cif + ganancia

        # Calcular precio por unidad
        if unidades_obtenidas > 0:
            precio_venta_unidad = precio_total_preparacion / unidades_obtenidas
        else:
            precio_venta_unidad = 0

        # Calcular mÃ©tricas de rentabilidad
        if unidades_obtenidas > 0:
            costo_unitario = costo_total_con_cif / unidades_obtenidas
        else:
            costo_unitario = 0

        margen_contribucion = precio_venta_unidad - costo_unitario

        if precio_venta_unidad > 0:
            margen_porcentaje = (margen_contribucion / precio_venta_unidad) * 100
        else:
            margen_porcentaje = 0

        if margen_contribucion > 0:
            punto_equilibrio = int(costo_total_con_cif / margen_contribucion)
        else:
            punto_equilibrio = 0

        if costo_total_con_cif > 0:
            rentabilidad_porcentaje = (ganancia / costo_total_con_cif) * 100
        else:
            rentabilidad_porcentaje = 0
        
        return jsonify({
            'success': True,
            'costo_materia_prima': round(costo_mp, 2),
            'cif': round(cif, 2),
            'costo_total': round(costo_total_con_cif, 2),
            'ganancia': round(ganancia, 2),
            'precio_total_preparacion': round(precio_total_preparacion, 2),
            'precio_venta_unidad': round(precio_venta_unidad, 2),
            'peso_total': round(peso_total, 2),
            'unidades_obtenidas': unidades_obtenidas,
            'margen_contribucion': round(margen_contribucion, 2),
            'margen_porcentaje': round(margen_porcentaje, 2),
            'punto_equilibrio': punto_equilibrio,
            'rentabilidad_porcentaje': round(rentabilidad_porcentaje, 2),
            'costo_unitario': round(costo_unitario, 2)
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/crear_receta', methods=['GET', 'POST'])
@login_required
@modulo_requerido('produccion')
def crear_receta():
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    # âœ… DEBUG PARA CONFIRMAR PANADERÃA
    panaderia_actual = session.get('panaderia_id')
    print(f"ðŸ” DEBUG CREAR_RECETA: PanaderÃ­a actual: {panaderia_actual}")
    print(f"ðŸ” DEBUG CREAR_RECETA: User ID: {session.get('user_id')}")
    
    # VERIFICAR QUE HAY MATERIAS PRIMAS DISPONIBLES
    materias_primas = MateriaPrima.query.filter_by(activo=True).all()
    print(f"ðŸ” Materias primas encontradas: {len(materias_primas)}")
    
    # ... resto del cÃ³digo ...
    
    if request.method == 'POST':
        try:
            # âœ… CAPTURAR PRECIO REAL DEL FORMULARIO
            precio_venta_real = float(request.form.get('precio_venta_real', 0)) or 0
            
            # Crear la receta base
            nueva_receta = Receta(
                nombre=request.form['nombre'],
                descripcion=request.form.get('descripcion', ''),
                categoria=request.form['categoria'],
                peso_unidad_gramos=float(request.form['peso_unidad_gramos']),
                porcentaje_perdida=float(request.form.get('porcentaje_perdida', 10.0)),
                activo=True,
                precio_venta_real=precio_venta_real,  # âœ… ASIGNAR PRECIO REAL
                panaderia_id=session.get('panaderia_id')  # âœ… FILTRO MULTICLIENTE CRÃTICO
            )
            
            db.session.add(nueva_receta)
            db.session.flush()  # Para obtener el ID
            
            # Procesar ingredientes - USANDO GRAMOS DIRECTOS
            ingredientes_data = []
            costo_total_materias_primas = 0
            peso_total_masa = 0

            # Recoger ingredientes del formulario
            i = 0
            while f'ingredientes[{i}][materia_prima_id]' in request.form:
                materia_prima_id = request.form[f'ingredientes[{i}][materia_prima_id]']
                gramos = float(request.form[f'ingredientes[{i}][gramos]'])  # Gramos directos
                
                materia_prima = MateriaPrima.query.get(materia_prima_id)
                if materia_prima and gramos > 0:
                    cantidad_gramos = gramos
                    costo_ingrediente = cantidad_gramos * materia_prima.costo_promedio
                    
                    ingrediente = RecetaIngrediente(
                        receta_id=nueva_receta.id,
                        materia_prima_id=materia_prima_id,
                        porcentaje_aplicado=0,  # Se calcularÃ¡ despuÃ©s
                        cantidad_gramos=cantidad_gramos,
                        costo_ingrediente=costo_ingrediente
                    )
                    
                    db.session.add(ingrediente)
                    costo_total_materias_primas += costo_ingrediente
                    peso_total_masa += cantidad_gramos
                    ingredientes_data.append(ingrediente)
                
                i += 1
            
            # Calcular porcentajes despuÃ©s de tener el peso total
            for ingrediente in ingredientes_data:
                if peso_total_masa > 0:
                    ingrediente.porcentaje_aplicado = (ingrediente.cantidad_gramos / peso_total_masa) * 100
            
            # CALCULAR DATOS DE PRODUCCIÃ“N
            unidades_obtenidas = int(peso_total_masa / nueva_receta.peso_unidad_gramos) if nueva_receta.peso_unidad_gramos > 0 else 0
            peso_horneado_unidad = nueva_receta.peso_unidad_gramos - (nueva_receta.peso_unidad_gramos * (nueva_receta.porcentaje_perdida / 100))
            costo_indirecto = costo_total_materias_primas * 0.45  # 45% CIF
            costo_total_produccion = costo_total_materias_primas + costo_indirecto
            margen_ganancia = costo_total_produccion * 0.45  # 45% de ganancia
            precio_venta_unitario = (costo_total_produccion + margen_ganancia) / unidades_obtenidas if unidades_obtenidas > 0 else 0
            precio_por_gramo = precio_venta_unitario / nueva_receta.peso_unidad_gramos if nueva_receta.peso_unidad_gramos > 0 else 0
            
            # âœ… ACTUALIZAR RECETA CON TODOS LOS DATOS CALCULADOS (INCLUYENDO PRECIO REAL)
            nueva_receta.peso_total_masa = peso_total_masa
            nueva_receta.unidades_obtenidas = unidades_obtenidas
            nueva_receta.peso_horneado_unidad = peso_horneado_unidad
            nueva_receta.costo_materias_primas = costo_total_materias_primas
            nueva_receta.costo_indirecto = costo_indirecto
            nueva_receta.costo_total = costo_total_produccion
            nueva_receta.margen_ganancia = margen_ganancia
            nueva_receta.precio_venta_unitario = precio_venta_unitario
            nueva_receta.precio_por_gramo = precio_por_gramo
            nueva_receta.precio_venta = precio_venta_unitario * unidades_obtenidas
            # âœ… precio_venta_real ya fue asignado al crear la receta
            
            # âœ… NUEVO: CREAR PRODUCTO AUTOMÃTICAMENTE A PARTIR DE LA RECETA
            # âœ… NUEVO: CREAR PRODUCTO AUTOMÃTICAMENTE A PARTIR DE LA RECETA
            producto_automatico = Producto(
                nombre=nueva_receta.nombre,
                descripcion=nueva_receta.descripcion,
                categoria_id=obtener_categoria_id(nueva_receta.categoria),
                precio_venta=precio_venta_real if precio_venta_real > 0 else precio_venta_unitario,
                stock_actual=0,  # Inicialmente sin stock - se llena con producciÃ³n
                stock_minimo=10,
                codigo_barras=f"PROD{nueva_receta.id:06d}",
                tipo_producto='produccion',
                es_pan=True if 'pan' in nueva_receta.nombre.lower() else False,
                receta_id=nueva_receta.id,
                activo=True,
                panaderia_id=session.get('panaderia_id')  # âœ… FILTRO MULTICLIENTE
            )
            
            db.session.add(producto_automatico)
            db.session.flush()  # Para obtener el ID del producto
            
            # âœ… ASIGNAR EL PRODUCTO A LA RECETA (relaciÃ³n bidireccional)
            nueva_receta.producto_id = producto_automatico.id
            
            db.session.commit()
            
            # âœ… MENSAJE MEJORADO QUE INCLUYE LA CREACIÃ“N DEL PRODUCTO
            mensaje = f'âœ… Receta "{nueva_receta.nombre}" creada exitosamente! '
            mensaje += f'Peso total: {peso_total_masa:,.0f}g | '
            mensaje += f'Unidades: {unidades_obtenidas} | '
            mensaje += f'Precio teÃ³rico: ${precio_venta_unitario:,.0f}'
            
            if precio_venta_real > 0:
                mensaje += f' | Precio real: ${precio_venta_real:,.0f}'
                # âœ… CALCULAR Y MOSTRAR UTILIDAD REAL INMEDIATAMENTE
                utilidad_pesos = nueva_receta.utilidad_real_pesos
                utilidad_porcentaje = nueva_receta.utilidad_real_porcentaje
                mensaje += f' | Utilidad: ${utilidad_pesos:,.0f} ({utilidad_porcentaje:.1f}%)'
            
            mensaje += f' | âœ… Producto automÃ¡tico creado: {producto_automatico.nombre}'
            
            flash(mensaje, 'success')
            return redirect(url_for('recetas'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'âŒ Error al crear la receta: {str(e)}', 'error')
            return redirect(url_for('crear_receta'))
    
    return render_template('crear_receta.html', materias_primas=materias_primas)

# âœ… NUEVA FUNCIÃ“N HELPER - AGREGAR ESTA FUNCIÃ“N EN app.py
def obtener_categoria_id(nombre_categoria):
    """Obtiene el ID de categorÃ­a basado en el nombre - crea si no existe"""
    # Normalizar nombre de categorÃ­a
    nombre_categoria = nombre_categoria.strip().title()
    
    categoria = Categoria.query.filter_by(nombre=nombre_categoria).first()
    if not categoria:
        # Crear categorÃ­a si no existe
        categoria = Categoria(nombre=nombre_categoria)
        db.session.add(categoria)
        db.session.commit()
        print(f"âœ… Nueva categorÃ­a creada: {nombre_categoria}")
    
    return categoria.id

# âœ… RUTA MEJORADA PARA EDITAR RECETAS EXISTENTES
@app.route('/editar_receta/<int:id>', methods=['GET', 'POST'])
@login_required
@modulo_requerido('produccion')
def editar_receta(id):
    """Editar una receta existente - AHORA CON PRECIO REAL"""
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    receta = Receta.query.get_or_404(id)
    materias_primas = MateriaPrima.query.filter_by(activo=True).all()
    
    if request.method == 'POST':
        try:
            # âœ… ACTUALIZAR PRECIO REAL EN EDICIÃ“N
            nuevo_precio_real = float(request.form.get('precio_venta_real', 0)) or 0
            
            receta.nombre = request.form['nombre']
            receta.descripcion = request.form.get('descripcion', '')
            receta.categoria = request.form['categoria']
            receta.peso_unidad_gramos = float(request.form['peso_unidad_gramos'])
            receta.porcentaje_perdida = float(request.form.get('porcentaje_perdida', 10.0))
            receta.precio_venta_real = nuevo_precio_real  # âœ… ACTUALIZAR PRECIO REAL
            
            # âœ… ELIMINAR INGREDIENTES EXISTENTES Y AGREGAR NUEVOS
            RecetaIngrediente.query.filter_by(receta_id=receta.id).delete()
            
            # Reprocesar ingredientes (misma lÃ³gica que crear)
            costo_total_materias_primas = 0
            peso_total_masa = 0
            ingredientes_data = []
            
            i = 0
            while f'ingredientes[{i}][materia_prima_id]' in request.form:
                materia_prima_id = request.form[f'ingredientes[{i}][materia_prima_id]']
                gramos = float(request.form[f'ingredientes[{i}][gramos]'])
                
                materia_prima = MateriaPrima.query.get(materia_prima_id)
                if materia_prima and gramos > 0:
                    cantidad_gramos = gramos
                    costo_ingrediente = cantidad_gramos * materia_prima.costo_promedio
                    
                    ingrediente = RecetaIngrediente(
                        receta_id=receta.id,
                        materia_prima_id=materia_prima_id,
                        porcentaje_aplicado=0,
                        cantidad_gramos=cantidad_gramos,
                        costo_ingrediente=costo_ingrediente
                    )
                    
                    db.session.add(ingrediente)
                    costo_total_materias_primas += costo_ingrediente
                    peso_total_masa += cantidad_gramos
                    ingredientes_data.append(ingrediente)
                
                i += 1
            
            # Recalcular porcentajes
            for ingrediente in ingredientes_data:
                if peso_total_masa > 0:
                    ingrediente.porcentaje_aplicado = (ingrediente.cantidad_gramos / peso_total_masa) * 100
            
            # âœ… RECALCULAR TODOS LOS DATOS DE PRODUCCIÃ“N
            unidades_obtenidas = int(peso_total_masa / receta.peso_unidad_gramos) if receta.peso_unidad_gramos > 0 else 0
            peso_horneado_unidad = receta.peso_unidad_gramos - (receta.peso_unidad_gramos * (receta.porcentaje_perdida / 100))
            costo_indirecto = costo_total_materias_primas * 0.45
            costo_total_produccion = costo_total_materias_primas + costo_indirecto
            margen_ganancia = costo_total_produccion * 0.45
            precio_venta_unitario = (costo_total_produccion + margen_ganancia) / unidades_obtenidas if unidades_obtenidas > 0 else 0
            precio_por_gramo = precio_venta_unitario / receta.peso_unidad_gramos if receta.peso_unidad_gramos > 0 else 0
            
            # âœ… ACTUALIZAR CAMPOS RECALCULADOS
            receta.peso_total_masa = peso_total_masa
            receta.unidades_obtenidas = unidades_obtenidas
            receta.peso_horneado_unidad = peso_horneado_unidad
            receta.costo_materias_primas = costo_total_materias_primas
            receta.costo_indirecto = costo_indirecto
            receta.costo_total = costo_total_produccion
            receta.margen_ganancia = margen_ganancia
            receta.precio_venta_unitario = precio_venta_unitario
            receta.precio_por_gramo = precio_por_gramo
            receta.precio_venta = precio_venta_unitario * unidades_obtenidas
            
            db.session.commit()
            
            flash(f'âœ… Receta "{receta.nombre}" actualizada! Precio real: ${nuevo_precio_real:,.0f}', 'success')
            return redirect(url_for('detalle_receta', id=receta.id))
            
        except Exception as e:
            db.session.rollback()
            flash(f'âŒ Error al actualizar la receta: {str(e)}', 'error')
            return redirect(url_for('editar_receta', id=id))
    
    # Para GET, mostrar formulario con datos existentes
    return render_template('crear_receta.html', 
                         receta=receta, 
                         materias_primas=materias_primas, 
                         editar=True)
    
    

# =============================================
# RUTA DE DIAGNÃ“STICO - PRODUCTOS Y PUNTO DE VENTA
# =============================================

@app.route('/diagnostico_productos')
@login_required
@modulo_requerido('sistema')
def diagnostico_productos():
    """PÃ¡gina de diagnÃ³stico para verificar productos y punto de venta"""
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    # Obtener todos los productos
    productos = Producto.query.all()
    
    # Obtener recetas con/sin producto
    recetas = Receta.query.all()
    
    # Probar la bÃºsqueda
    resultados_busqueda_pan = []
    try:
        productos_pan = Producto.query.filter(
            Producto.activo == True,
            db.or_(
                Producto.nombre.ilike(f'%pan%'),
                Producto.codigo_barras.ilike(f'%pan%')
            )
        ).all()
        
        for producto in productos_pan:
            resultados_busqueda_pan.append({
                'nombre': producto.nombre,
                'stock': producto.stock_actual,
                'precio': producto.precio_venta,
                'activo': producto.activo,
                'tipo': producto.tipo_producto
            })
    except Exception as e:
        resultados_busqueda_pan = f"Error en bÃºsqueda: {str(e)}"
    
    diagnostico = {
        'total_productos': len(productos),
        'total_recetas': len(recetas),
        'recetas_sin_producto': [],
        'productos_con_receta': [],
        'productos_externos': [],
        'productos_activos': [],
        'productos_con_stock': [],
        'busqueda_pan': resultados_busqueda_pan
    }
    
    for receta in recetas:
        if not receta.producto:
            diagnostico['recetas_sin_producto'].append({
                'id': receta.id,
                'nombre': receta.nombre,
                'categoria': receta.categoria
            })
        else:
            diagnostico['productos_con_receta'].append({
                'id': receta.producto.id,
                'nombre': receta.producto.nombre,
                'receta': receta.nombre,
                'stock': receta.producto.stock_actual,
                'precio': receta.producto.precio_venta,
                'activo': receta.producto.activo
            })
    
    for producto in productos:
        if producto.activo:
            diagnostico['productos_activos'].append({
                'nombre': producto.nombre,
                'stock': producto.stock_actual,
                'precio': producto.precio_venta,
                'tipo': producto.tipo_producto
            })
            
        if producto.stock_actual > 0:
            diagnostico['productos_con_stock'].append({
                'nombre': producto.nombre,
                'stock': producto.stock_actual,
                'precio': producto.precio_venta
            })
            
        if producto.tipo_producto == 'externo':
            diagnostico['productos_externos'].append({
                'nombre': producto.nombre,
                'stock': producto.stock_actual
            })
    
    return render_template('diagnostico_productos.html', diagnostico=diagnostico)
    
# =============================================
# RUTAS DE PRODUCCIÃ“N DIARIA - NUEVO MÃ“DULO
# =============================================



@app.route('/produccion_diaria')
@login_required
@modulo_requerido('produccion')
def produccion_diaria():
    """Dashboard principal de producciÃ³n diaria - SOLO datos de esta panaderÃ­a"""
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    # âœ… FILTRO CLAVE: Solo datos de ESTA panaderÃ­a (CON ACCESO REMOTO)
    panaderia_actual = obtener_panaderia_actual()  # â† ÃšNICO CAMBIO EN FILTRO
    
    print(f"ðŸ” DEBUG: PanaderÃ­a actual: {panaderia_actual}")
    
    # âœ… âœ… âœ… NUEVO: BLOQUE SUPER USUARIO (MEJORADO) âœ… âœ… âœ…
    if es_super_usuario() and not session.get('panaderia_remota'):
        flash("ðŸ”§ Como super usuario, usa 'Acceder a esta panaderÃ­a' para ver producciÃ³n especÃ­fica", "info")
        return render_template('produccion_diaria.html',
                             recetas_con_stock=[],
                             ordenes_activas=[],
                             todas_las_ordenes_completadas=[],
                             alertas=[])
    # âœ… âœ… âœ… FIN BLOQUE SUPER USUARIO âœ… âœ… âœ…
    
    # âœ… SOLO DIAGNÃ“STICO - NO crear recetas automÃ¡ticas
    hay_recetas = diagnosticar_recetas(panaderia_actual)
    
    if not hay_recetas:
        print("âš ï¸  NO hay recetas activas. Debes crearlas en el mÃ³dulo 'FÃ³rmulas y Recetas'")
        flash("No hay recetas disponibles. Crea recetas en el mÃ³dulo 'FÃ³rmulas y Recetas' primero.", "warning")
    
    
    
    # Obtener recetas activas de ESTA panaderÃ­a
    recetas_activas = Receta.query.filter_by(
        activo=True,
        panaderia_id=panaderia_actual
    ).all()
    
    print(f"ðŸ” DEBUG: Recetas activas encontradas: {len(recetas_activas)}")
    
    recetas_con_stock = []
    alertas = []
    
    for receta in recetas_activas:
        # Calcular stock actual (usar funciÃ³n real o 0 si no existe)
        try:
            stock_actual = calcular_stock_vitrina(receta.id)
        except:
            stock_actual = 0  # Si la funciÃ³n no existe o falla
        
        # Obtener configuraciÃ³n personalizada
        config = ConfiguracionProduccion.query.filter_by(receta_id=receta.id).first()
        if not config:
            # Crear configuraciÃ³n por defecto si no existe
            config = ConfiguracionProduccion(
                receta_id=receta.id,
                stock_minimo=10,
                stock_objetivo=50,
                stock_maximo=100,
                rotacion_diaria_esperada=10.0
            )
            db.session.add(config)
            db.session.commit()
        
        stock_minimo_personalizado = config.stock_minimo
        
        # Calcular ventas del dÃ­a actual
        try:
            hoy = datetime.now().date()
            ventas_hoy = calcular_ventas_hoy(receta.nombre, hoy)
        except:
            ventas_hoy = 0
        
        # ProyecciÃ³n de agotamiento
        proyeccion_horas = None
        if config.rotacion_diaria_esperada > 0 and stock_actual > 0:
            horas_restantes = (stock_actual / config.rotacion_diaria_esperada) * 24
            if horas_restantes < 168:
                proyeccion_horas = int(horas_restantes)
        
        # Generar alertas
        if stock_actual <= stock_minimo_personalizado:
            alertas.append({
                'nivel': 'critico',
                'mensaje': f'ðŸ”´ STOCK CRÃTICO: {receta.nombre} - Solo {stock_actual} unidades (MÃ­nimo: {stock_minimo_personalizado})'
            })
        elif stock_actual <= (stock_minimo_personalizado * 2):
            alertas.append({
                'nivel': 'advertencia', 
                'mensaje': f'ðŸŸ¡ STOCK BAJO: {receta.nombre} - {stock_actual} unidades (MÃ­nimo: {stock_minimo_personalizado})'
            })
        elif stock_actual >= config.stock_maximo:
            alertas.append({
                'nivel': 'info',
                'mensaje': f'ðŸ”µ STOCK ALTO: {receta.nombre} - {stock_actual} unidades (MÃ¡ximo: {config.stock_maximo})'
            })
        
        recetas_con_stock.append({
            'id': receta.id,
            'nombre': receta.nombre,
            'stock_actual': stock_actual,
            'stock_minimo': stock_minimo_personalizado,
            'stock_maximo': config.stock_maximo,
            'ventas_hoy': ventas_hoy,
            'proyeccion_horas': proyeccion_horas,
            'rotacion_esperada': config.rotacion_diaria_esperada,
            'config': config
        })
    
    
    
    # âœ… Obtener Ã³rdenes de producciÃ³n activas SOLO de esta panaderÃ­a
    ordenes_activas = OrdenProduccion.query.filter(
        OrdenProduccion.estado.in_(['PENDIENTE', 'EN_PRODUCCION']),
        OrdenProduccion.panaderia_id == panaderia_actual  # â† FILTRO MULTICLIENTE
    ).order_by(OrdenProduccion.fecha_produccion.desc()).limit(10).all()
    
    # âœ… Obtener Ã³rdenes completadas del dÃ­a SOLO de esta panaderÃ­a
    hoy = datetime.now().date()
    ordenes_completadas_hoy_db = OrdenProduccion.query.filter(
        OrdenProduccion.estado == 'COMPLETADA',
        db.func.date(OrdenProduccion.fecha_fin) == hoy,
        OrdenProduccion.panaderia_id == panaderia_actual  # â† FILTRO MULTICLIENTE
    ).all()
    
    print(f"ðŸ” DEBUG: Recetas con stock procesadas: {len(recetas_con_stock)}")
    print(f"ðŸ” DEBUG: Alertas generadas: {len(alertas)}")
    print(f"ðŸ” DEBUG: Ã“rdenes activas: {len(ordenes_activas)}")
    
    return render_template('produccion_diaria.html',
                         recetas_con_stock=recetas_con_stock,
                         ordenes_activas=ordenes_activas,
                         todas_las_ordenes_completadas=ordenes_completadas_hoy_db,
                         alertas=alertas)
    
# âœ… NUEVA RUTA: ConfiguraciÃ³n personalizada de stock por producto
@app.route('/configurar_stock_producto/<int:receta_id>', methods=['GET', 'POST'])
@login_required
@modulo_requerido('produccion')
def configurar_stock_producto(receta_id):
    """ConfiguraciÃ³n personalizada de stock por producto"""
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    receta = Receta.query.get_or_404(receta_id)
    config = ConfiguracionProduccion.query.filter_by(receta_id=receta_id).first()
    
    # Crear configuraciÃ³n si no existe
    if not config:
        config = ConfiguracionProduccion(
            receta_id=receta_id,
            stock_minimo=10,
            stock_objetivo=50,
            stock_maximo=100,
            rotacion_diaria_esperada=10.0
        )
        db.session.add(config)
        db.session.commit()
    
    if request.method == 'POST':
        try:
            # Actualizar configuraciÃ³n
            config.stock_minimo = int(request.form['stock_minimo'])
            config.stock_objetivo = int(request.form['stock_objetivo'])
            config.stock_maximo = int(request.form['stock_maximo'])
            config.rotacion_diaria_esperada = float(request.form['rotacion_diaria_esperada'])
            config.tendencia_ventas = float(request.form.get('tendencia_ventas', 1.0))
            config.fecha_actualizacion = datetime.utcnow()
            
            db.session.commit()
            flash(f'âœ… ConfiguraciÃ³n de stock para "{receta.nombre}" actualizada', 'success')
            return redirect(url_for('produccion_diaria'))
            
        except Exception as e:
            flash(f'âŒ Error al actualizar configuraciÃ³n: {str(e)}', 'error')
    
    # Obtener estadÃ­sticas reales para sugerencias
    stock_actual = calcular_stock_vitrina(receta_id)
    ventas_ultima_semana = calcular_ventas_ultima_semana(receta.nombre)
    
    return render_template('configurar_stock_producto.html', 
                         receta=receta, 
                         config=config,
                         stock_actual=stock_actual,
                         ventas_ultima_semana=ventas_ultima_semana)

# âœ… NUEVA FUNCIÃ“N: Calcular ventas de la Ãºltima semana
def calcular_ventas_ultima_semana(nombre_receta):
    """Calcular ventas de los Ãºltimos 7 dÃ­as para una receta"""
    try:
        fecha_inicio = datetime.now().date() - timedelta(days=7)
        
        ventas_semana = db.session.query(
            db.func.sum(DetalleVenta.cantidad)
        ).join(Producto).join(Venta).filter(
            Producto.nombre == nombre_receta,
            Venta.fecha_hora >= fecha_inicio
        ).scalar() or 0
        
        return ventas_semana
    except Exception as e:
        print(f"Error calculando ventas semana: {e}")
        return 0
    
# âœ… NUEVO: Ruta para configurar stock mÃ­nimo por receta
@app.route('/configurar_stock/<int:receta_id>', methods=['GET', 'POST'])
@login_required
@modulo_requerido('produccion')
def configurar_stock(receta_id):
    """Configurar stock objetivo y parÃ¡metros para una receta"""
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    receta = Receta.query.get_or_404(receta_id)
    config = ConfiguracionProduccion.query.filter_by(receta_id=receta_id).first()
    
    if not config:
        config = ConfiguracionProduccion(receta_id=receta_id)
        db.session.add(config)
        db.session.commit()
    
    if request.method == 'POST':
        try:
            config.stock_objetivo = int(request.form['stock_objetivo'])
            config.porcentaje_critico = float(request.form['porcentaje_critico'])
            config.porcentaje_bajo = float(request.form['porcentaje_bajo'])
            config.porcentaje_medio = float(request.form['porcentaje_medio'])
            config.tendencia_ventas = float(request.form.get('tendencia_ventas', 1.0))
            config.fecha_actualizacion = datetime.utcnow()
            
            db.session.commit()
            flash(f'âœ… ConfiguraciÃ³n de stock para "{receta.nombre}" actualizada', 'success')
            return redirect(url_for('produccion_diaria'))
            
        except Exception as e:
            flash(f'âŒ Error al actualizar configuraciÃ³n: {str(e)}', 'error')
    
    return render_template('configurar_stock.html', receta=receta, config=config)

# âœ… NUEVO: API para obtener configuraciÃ³n de stock
@app.route('/api/configuracion_stock/<int:receta_id>')
@login_required
@modulo_requerido('produccion')
def api_configuracion_stock(receta_id):
    """API para obtener configuraciÃ³n de stock de una receta"""
    if 'user_id' not in session:
        return jsonify({'error': 'No autorizado'}), 401
    
    config = ConfiguracionProduccion.query.filter_by(receta_id=receta_id).first()
    if not config:
        config = ConfiguracionProduccion(receta_id=receta_id)
        db.session.add(config)
        db.session.commit()
    
    return jsonify({
        'stock_objetivo': config.stock_objetivo,
        'porcentaje_critico': config.porcentaje_critico,
        'porcentaje_bajo': config.porcentaje_bajo,
        'porcentaje_medio': config.porcentaje_medio,
        'tendencia_ventas': config.tendencia_ventas
    })

@app.route('/produccion/ordenar_produccion', methods=['POST'])
@login_required
@modulo_requerido('produccion')
def ordenar_produccion():
    """Crear nueva orden de producciÃ³n desde el dashboard"""
    if 'user_id' not in session:
        return jsonify({'error': 'No autorizado'}), 401
    
    try:
        receta_id = request.form.get('receta_id', type=int)
        cantidad = request.form.get('cantidad', type=int)
        
        if not receta_id or not cantidad or cantidad <= 0:
            return jsonify({'error': 'Datos invÃ¡lidos'}), 400
        
        # âœ… AGREGADO: Filtro multicliente
        panaderia_actual = session.get('panaderia_id')
        receta = Receta.query.filter_by(id=receta_id, panaderia_id=panaderia_actual).first()
        
        if not receta:
            return jsonify({'error': 'Receta no encontrada'}), 404
        
        # Crear orden de producciÃ³n
        nueva_orden = OrdenProduccion(
            receta_id=receta_id,
            cantidad_producir=cantidad,
            estado='PENDIENTE',
            usuario_id=session['user_id'],
            panaderia_id=panaderia_actual  # âœ… AGREGADO: Filtro multicliente
        )
        
        db.session.add(nueva_orden)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'orden_id': nueva_orden.id,
            'mensaje': f'Orden de producciÃ³n creada para {cantidad} unidades'
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500


@app.route('/debug_produccion')
@login_required
@modulo_requerido('produccion')
def debug_produccion():
    """PÃ¡gina de debug para producciÃ³n"""
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    # Obtener Ã³rdenes de producciÃ³n
    ordenes = OrdenProduccion.query.all()
    
    debug_info = {
        'total_ordenes': len(ordenes),
        'ordenes_detalle': []
    }
    
    for orden in ordenes:
        debug_info['ordenes_detalle'].append({
            'id': orden.id,
            'receta': orden.receta.nombre if orden.receta else 'N/A',
            'cantidad': orden.cantidad_producir,
            'estado': orden.estado,
            'producto_asociado': orden.receta.producto.nombre if orden.receta and orden.receta.producto else 'NO',
            'stock_actual': orden.receta.producto.stock_actual if orden.receta and orden.receta.producto else 0
        })
    
    return render_template('debug_produccion.html', debug=debug_info)
# =============================================
# âœ… NUEVAS FUNCIONES PARA APRENDIZAJE AUTOMÃTICO
# =============================================

def calcular_rotacion_automatica(producto_id, dias_historial=30):
    """Calcula la rotaciÃ³n diaria automÃ¡tica basada en historial real"""
    try:
        fecha_inicio = datetime.now().date() - timedelta(days=dias_historial)
        
        # Obtener ventas de los Ãºltimos 'dias_historial' dÃ­as
        ventas_totales = db.session.query(
            db.func.sum(DetalleVenta.cantidad)
        ).join(Venta).filter(
            DetalleVenta.producto_id == producto_id,
            Venta.fecha_hora >= fecha_inicio
        ).scalar() or 0
        
        # Calcular promedio diario (excluyendo dÃ­as sin ventas)
        dias_con_ventas = db.session.query(
            db.func.count(db.distinct(db.func.date(Venta.fecha_hora)))
        ).join(DetalleVenta).filter(
            DetalleVenta.producto_id == producto_id,
            Venta.fecha_hora >= fecha_inicio
        ).scalar() or 1  # Evitar divisiÃ³n por cero
        
        rotacion_promedio = ventas_totales / dias_con_ventas
        
        return round(rotacion_promedio, 2)
    except Exception as e:
        print(f"âŒ Error calculando rotaciÃ³n automÃ¡tica: {e}")
        return 10.0  # Valor por defecto

def actualizar_rotaciones_automaticas():
    """Actualiza automÃ¡ticamente todas las rotaciones basado en datos histÃ³ricos"""
    try:
        productos_activos = Producto.query.filter_by(activo=True).all()
        actualizaciones = 0
        
        for producto in productos_activos:
            if producto.receta:  # Solo productos con receta
                config = ConfiguracionProduccion.query.filter_by(receta_id=producto.receta.id).first()
                if config:
                    nueva_rotacion = calcular_rotacion_automatica(producto.id)
                    
                    # Solo actualizar si hay cambio significativo (> 10%)
                    cambio_significativo = abs(config.rotacion_diaria_esperada - nueva_rotacion) > (config.rotacion_diaria_esperada * 0.1)
                    
                    if cambio_significativo:
                        config.rotacion_diaria_esperada = nueva_rotacion
                        actualizaciones += 1
                        
                        # âœ… CORREGIDO: HistorialRotacionProducto (no historicalRotacionProducto)
                        historial = HistorialRotacionProducto(
                            producto_id=producto.id,
                            rotacion_real=nueva_rotacion
                        )
                        db.session.add(historial)
        
        db.session.commit()
        print(f"âœ… Rotaciones automÃ¡ticas actualizadas: {actualizaciones} productos")
        return actualizaciones
    except Exception as e:
        db.session.rollback()
        print(f"âŒ Error actualizando rotaciones automÃ¡ticas: {e}")
        return 0

def actualizar_control_vida_util():
    """Actualiza el control de vida Ãºtil de todos los productos"""
    try:
        productos_pan = Producto.query.filter_by(es_pan=True, activo=True).all()
        hoy = datetime.now().date()
        
        for producto in productos_pan:
            # Buscar registro de vida Ãºtil del dÃ­a
            control = ControlVidaUtil.query.filter_by(
                producto_id=producto.id, 
                fecha_produccion=hoy
            ).first()
            
            if not control and producto.stock_actual > 0:
                # Crear nuevo registro para el dÃ­a
                # âœ… CORREGIDO: dias_sin_rotacion (no dÃ­as_sin_notacion)
                control = ControlVidaUtil(
                    producto_id=producto.id,
                    fecha_produccion=hoy,
                    stock_inicial=producto.stock_actual,
                    stock_actual=producto.stock_actual,
                    dias_sin_rotacion=0,
                    estado='FRESCO'
                )
                db.session.add(control)
            elif control:
                # Actualizar stock actual
                control.stock_actual = producto.stock_actual
                
                # Calcular rotaciÃ³n del dÃ­a
                rotacion_hoy = control.stock_inicial - control.stock_actual
                
                if rotacion_hoy == 0:
                    control.dias_sin_rotacion += 1
                else:
                    control.dias_sin_rotacion = 0
                
                # Determinar estado basado en dÃ­as sin rotaciÃ³n
                if control.dias_sin_rotacion >= 3:
                    control.estado = 'PERDIDA'
                elif control.dias_sin_rotacion == 2:
                    control.estado = 'RIESGO'
                elif control.dias_sin_rotacion == 1:
                    control.estado = 'ALERTA'
                else:
                    control.estado = 'FRESCO'
        
        db.session.commit()
        print(f"âœ… Control de vida Ãºtil actualizado para {len(productos_pan)} productos")
    except Exception as e:
        db.session.rollback()
        print(f"âŒ Error actualizando control vida Ãºtil: {e}")
        
        
# FUNCIONES AUXILIARES PARA CÃLCULOS
def calcular_stock_vitrina(receta_id):
    """Calcular stock actual en vitrina para una receta"""
    try:
        receta = Receta.query.get(receta_id)
        print(f"ðŸ” DEBUG calcular_stock_vitrina: Receta: {receta.nombre if receta else 'N/A'}")
        
        # Si la receta tiene producto asociado, usar el stock del producto
        if receta and receta.producto:
            stock = receta.producto.stock_actual
            print(f"ðŸ” DEBUG: Usando stock del producto: {stock} unidades")
            return stock
        
        # MÃ©todo antiguo (backup)
        produccion_total = db.session.query(
            db.func.sum(OrdenProduccion.cantidad_producir)
        ).filter(
            OrdenProduccion.receta_id == receta_id,
            OrdenProduccion.estado == 'COMPLETADA'
        ).scalar() or 0
        
        ventas_totales = db.session.query(
            db.func.sum(DetalleVenta.cantidad)
        ).join(Producto).filter(
            Producto.nombre == receta.nombre
        ).scalar() or 0
        
        stock_calculado = max(0, produccion_total - ventas_totales)
        print(f"ðŸ” DEBUG: Stock calculado (mÃ©todo antiguo): {stock_calculado}")
        
        return stock_calculado
        
    except Exception as e:
        print(f"âŒ Error calculando stock: {e}")
        return 0

def calcular_ventas_hoy(nombre_receta, fecha):
    """Calcular ventas del dÃ­a actual para una receta"""
    try:
        inicio_dia = datetime.combine(fecha, datetime.min.time())
        fin_dia = datetime.combine(fecha, datetime.max.time())
        
        ventas_hoy = db.session.query(
            db.func.sum(DetalleVenta.cantidad)
        ).join(Producto).join(Venta).filter(
            Producto.nombre == nombre_receta,
            Venta.fecha_hora >= inicio_dia,
            Venta.fecha_hora <= fin_dia
        ).scalar() or 0
        
        return ventas_hoy
        
    except Exception as e:
        print(f"Error calculando ventas hoy: {e}")
        return 0
    
    

# =============================================
# NUEVAS RUTAS PARA PRODUCCIÃ“N DIARIA MEJORADA
# =============================================

@app.route('/produccion/iniciar_produccion/<int:orden_id>')
@login_required
@modulo_requerido('produccion')
def iniciar_produccion(orden_id):
    """Iniciar una orden de producciÃ³n - Cambia estado a EN_PRODUCCION"""
    if 'user_id' not in session:
        return jsonify({'error': 'No autorizado'}), 401
    
    try:
        # âœ… AGREGADO: Filtro multicliente
        panaderia_actual = session.get('panaderia_id')
        orden = OrdenProduccion.query.filter_by(id=orden_id, panaderia_id=panaderia_actual).first()
        
        if not orden:
            return jsonify({'error': 'Orden no encontrada'}), 404
        
        # Verificar que la orden estÃ© en estado PENDIENTE
        if orden.estado != 'PENDIENTE':
            return jsonify({'error': 'Solo se pueden iniciar Ã³rdenes pendientes'}), 400
        
        # Verificar disponibilidad de ingredientes
        suficiente, faltantes = orden.verificar_ingredientes_disponibles()
        if not suficiente:
            return jsonify({
                'error': 'Ingredientes insuficientes',
                'faltantes': faltantes
            }), 400
        
        # Iniciar producciÃ³n
        if orden.iniciar_produccion():
            db.session.commit()
            return jsonify({
                'success': True,
                'mensaje': f'ProducciÃ³n de {orden.receta.nombre} iniciada'
            })
        else:
            return jsonify({'error': 'No se pudo iniciar la producciÃ³n'}), 500
            
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@app.route('/produccion/confirmar_produccion/<int:orden_id>')
@login_required
@modulo_requerido('produccion')
def confirmar_produccion(orden_id):
    """Confirmar producciÃ³n completada - Actualiza stock y descuenta ingredientes"""
    if 'user_id' not in session:
        return jsonify({'error': 'No autorizado'}), 401
    
    try:
        # âœ… AGREGADO: Filtro multicliente
        panaderia_actual = session.get('panaderia_id')
        orden = OrdenProduccion.query.filter_by(id=orden_id, panaderia_id=panaderia_actual).first()
        
        if not orden:
            return jsonify({'error': 'Orden no encontrada'}), 404
        
        # Verificar que la orden estÃ© en estado EN_PRODUCCION
        if orden.estado != 'EN_PRODUCCION':
            return jsonify({'error': 'Solo se pueden confirmar Ã³rdenes en producciÃ³n'}), 400
        
        # Completar producciÃ³n (esto actualiza stock y descuenta ingredientes automÃ¡ticamente)
        if orden.completar_produccion():
            db.session.commit()
            return jsonify({
                'success': True,
                'mensaje': f'ProducciÃ³n de {orden.cantidad_producir} unidades de {orden.receta.nombre} completada. Stock actualizado.'
            })
        else:
            return jsonify({'error': 'No se pudo completar la producciÃ³n'}), 500
            
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@app.route('/produccion/cancelar_orden/<int:orden_id>')
@login_required
@modulo_requerido('produccion')
def cancelar_orden_produccion(orden_id):
    """Cancelar una orden de producciÃ³n"""
    if 'user_id' not in session:
        return jsonify({'error': 'No autorizado'}), 401
    
    try:
        # âœ… AGREGADO: Filtro multicliente
        panaderia_actual = session.get('panaderia_id')
        orden = OrdenProduccion.query.filter_by(id=orden_id, panaderia_id=panaderia_actual).first()
        
        if not orden:
            return jsonify({'error': 'Orden no encontrada'}), 404
        
        # Solo se pueden cancelar Ã³rdenes pendientes o en producciÃ³n
        if orden.estado not in ['PENDIENTE', 'EN_PRODUCCION']:
            return jsonify({'error': 'No se puede cancelar una orden completada'}), 400
        
        orden.estado = 'CANCELADA'
        db.session.commit()
        
        return jsonify({
            'success': True,
            'mensaje': f'Orden de producciÃ³n cancelada'
        })
            
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@app.route('/stock_vitrina')
@login_required
@modulo_requerido('produccion')
def stock_vitrina():
    """Vista completa de stock en vitrina - Nueva pestaÃ±a"""
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    # Obtener todas las recetas con su stock actual
    recetas_activas = Receta.query.filter_by(activo=True).all()
    
    stock_completo = []
    for receta in recetas_activas:
        stock_actual = calcular_stock_vitrina(receta.id)
        
        # Obtener configuraciÃ³n
        config = ConfiguracionProduccion.query.filter_by(receta_id=receta.id).first()
        if not config:
            config = ConfiguracionProduccion(receta_id=receta.id, stock_objetivo=50)
            db.session.add(config)
            db.session.commit()
        
        stock_completo.append({
            'id': receta.id,
            'nombre': receta.nombre,
            'stock_actual': stock_actual,
            'stock_objetivo': config.stock_objetivo,
            'categoria': receta.categoria,
            'estado': 'CRÃTICO' if stock_actual <= config.stock_objetivo * 0.2 else 
                     'BAJO' if stock_actual <= config.stock_objetivo * 0.5 else
                     'Ã“PTIMO' if stock_actual >= config.stock_objetivo else 'MEDIO'
        })
    
    # Ordenar por estado (crÃ­tico primero)
    stock_completo.sort(key=lambda x: ['CRÃTICO', 'BAJO', 'MEDIO', 'Ã“PTIMO'].index(x['estado']))
    
    return render_template('stock_vitrina.html', stock_completo=stock_completo)

@app.route('/reporte_produccion_diaria')
@login_required
@modulo_requerido('produccion')
def reporte_produccion_diaria():
    """Reporte imprimible de producciÃ³n diaria"""
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    hoy = datetime.now().date()
    
    # Ã“rdenes completadas hoy
    ordenes_hoy = OrdenProduccion.query.filter(
        OrdenProduccion.estado == 'COMPLETADA',
        db.func.date(OrdenProduccion.fecha_fin) == hoy
    ).all()
    
    # Stock actual
    recetas_activas = Receta.query.filter_by(activo=True).all()
    stock_actual = []
    for receta in recetas_activas:
        stock = calcular_stock_vitrina(receta.id)
        stock_actual.append({
            'nombre': receta.nombre,
            'stock': stock,
            'categoria': receta.categoria
        })
    
    # MÃ©tricas del dÃ­a
    total_producido = sum(orden.cantidad_producir for orden in ordenes_hoy)
    total_recetas = len(set(orden.receta_id for orden in ordenes_hoy))
    
    return render_template("reporte_produccion.html",
                         ordenes_hoy=ordenes_hoy,
                         stock_actual=stock_actual,
                         total_producido=total_producido,
                         total_recetas=total_recetas,
                         fecha=hoy)
    
# =============================================
# âœ… NUEVAS RUTAS PARA PUNTO DE VENTA INTELIGENTE
# =============================================

@app.route('/api/verificar_stock/<int:producto_id>')
@login_required
@modulo_requerido('punto_venta')
def verificar_stock_tiempo_real(producto_id):
    """API para verificar stock en tiempo real durante venta"""
    if 'user_id' not in session:
        return jsonify({'error': 'No autorizado'}), 401
    
    producto = Producto.query.get_or_404(producto_id)
    cantidad = request.args.get('cantidad', 1, type=int)
    
    # Obtener configuraciÃ³n de producciÃ³n si existe
    config = None
    if producto.receta:
        config = ConfiguracionProduccion.query.filter_by(receta_id=producto.receta.id).first()
    
    return jsonify({
        'stock_actual': producto.stock_actual,
        'stock_suficiente': producto.stock_actual >= cantidad,
        'alerta_reorden': producto.stock_actual <= (config.stock_minimo if config else 10),
        'produccion_sugerida': (config.stock_objetivo - producto.stock_actual) if config and config.stock_objetivo > producto.stock_actual else 0,
        'mensaje_alerta': f'Stock bajo: {producto.stock_actual} unidades' if producto.stock_actual <= (config.stock_minimo if config else 10) else None
    })

@app.route('/api/productos_sugeridos')
@login_required
@modulo_requerido('punto_venta')
def productos_sugeridos_venta():
    """API para obtener productos sugeridos basados en rotaciÃ³n"""
    if 'user_id' not in session:
        return jsonify({'error': 'No autorizado'}), 401
    
    # Productos con alta rotaciÃ³n y buen stock
    productos_alta_rotacion = []
    
    productos_activos = Producto.query.filter_by(activo=True).all()
    for producto in productos_activos:
        if producto.receta:
            config = ConfiguracionProduccion.query.filter_by(receta_id=producto.receta.id).first()
            if config and producto.stock_actual > 0:
                # Priorizar productos con alta rotaciÃ³n esperada
                if config.rotacion_diaria_esperada >= 5:  # Alta rotaciÃ³n
                    productos_alta_rotacion.append({
                        'id': producto.id,
                        'nombre': producto.nombre,
                        'precio': producto.precio_venta,
                        'stock_actual': producto.stock_actual,
                        'rotacion_esperada': config.rotacion_diaria_esperada
                    })
    
    # Ordenar por rotaciÃ³n esperada (mayor primero)
    productos_alta_rotacion.sort(key=lambda x: x['rotacion_esperada'], reverse=True)
    
    return jsonify(productos_alta_rotacion[:8])  # Top 8 productos

@app.route('/imprimir_factura/<int:factura_id>')
@login_required
@modulo_requerido('punto_venta')
def imprimir_factura(factura_id):
    """Generar vista imprimible - VersiÃ³n mejorada que detecta tipo de documento"""
    try:
        venta = Venta.query.get_or_404(factura_id)
        detalles = DetalleVenta.query.filter_by(venta_id=factura_id).all()
        config = obtener_configuracion_sistema()
        
        # ðŸ†• DETECTAR TIPO DE DOCUMENTO Y USAR TEMPLATE APROPIADO
        if venta.tipo_documento == 'ELECTRONICA':
            # Usar template de factura electrÃ³nica
            return render_template('factura_electronica.html',
                                venta=venta,
                                detalles=detalles,
                                config=config,
                                ahora=datetime.utcnow())
        else:
            # Usar template de recibo POS tradicional
            return render_template('recibo_pos.html',
                                venta=venta,
                                detalles=detalles,
                                config=config,
                                ahora=datetime.utcnow())
        
    except Exception as e:
        flash(f'âŒ Error generando documento: {str(e)}', 'error')
        return redirect(request.referrer or url_for('ventas'))
    
# En app.py - NUEVAS RUTAS PARA PRODUCTOS EXTERNOS

@app.route('/agregar_producto_externo', methods=['POST'])
@login_required
@modulo_requerido('productos')
def agregar_producto_externo():
    """Agregar nuevo producto externo al inventario"""
    if 'user_id' not in session:
        return jsonify({'success': False, 'message': 'No autorizado'}), 401
    
    try:
        # Obtener datos del formulario
        codigo_barras = request.form.get('codigo_barras', '').strip()
        nombre = request.form.get('nombre', '').strip()
        descripcion = request.form.get('descripcion', '').strip()
        categoria = request.form.get('categoria', '').strip()
        marca = request.form.get('marca', '').strip()
        proveedor_id = request.form.get('proveedor_id')
        stock_actual = request.form.get('stock_actual', 0)
        stock_minimo = request.form.get('stock_minimo', 0)
        precio_compra = request.form.get('precio_compra', 0)
        precio_venta = request.form.get('precio_venta', 0)
        
        # Validaciones bÃ¡sicas
        if not nombre:
            return jsonify({'success': False, 'message': 'âŒ El nombre del producto es requerido'})
        
        if not proveedor_id:
            return jsonify({'success': False, 'message': 'âŒ Debe seleccionar un proveedor'})
        
        # Verificar si el cÃ³digo de barras ya existe
        if codigo_barras:
            producto_existente = ProductoExterno.query.filter_by(codigo_barras=codigo_barras).first()
            if producto_existente:
                return jsonify({'success': False, 'message': 'âŒ Ya existe un producto con ese cÃ³digo de barras'})
        
        # Si no se proporciona cÃ³digo, generar uno Ãºnico
        import uuid
        if not codigo_barras:
            codigo_barras = str(uuid.uuid4().int)[:13]  # CÃ³digo Ãºnico de 13 dÃ­gitos
        
        # Convertir tipos de datos
        stock_actual = int(stock_actual) if stock_actual else 0
        stock_minimo = int(stock_minimo) if stock_minimo else 0
        precio_compra = float(precio_compra) if precio_compra else 0.0
        precio_venta = float(precio_venta) if precio_venta else 0.0
        
        # Validar precios
        if precio_venta <= precio_compra:
            return jsonify({'success': False, 'message': 'âŒ El precio de venta debe ser mayor al precio de compra'})
        
        # Crear nuevo producto
        nuevo_producto = ProductoExterno(
            codigo_barras=codigo_barras,
            nombre=nombre,
            descripcion=descripcion,
            categoria=categoria,
            marca=marca,
            proveedor_id=proveedor_id,
            stock_actual=stock_actual,
            stock_minimo=stock_minimo,
            precio_compra=precio_compra,
            precio_venta=precio_venta,
            activo=True
        )
        
        # Guardar en la base de datos
        db.session.add(nuevo_producto)
        db.session.commit()
        
        return jsonify({'success': True, 'message': f'âœ… Producto "{nombre}" agregado exitosamente'})
        
    except ValueError as e:
        db.session.rollback()
        return jsonify({'success': False, 'message': 'âŒ Error en los datos numÃ©ricos. Verifique los valores ingresados'})
    except Exception as e:
        db.session.rollback()
        print(f"Error: {e}")
        return jsonify({'success': False, 'message': 'âŒ Error al agregar el producto. Intente nuevamente'})
    

@app.route('/actualizar_stock_externo/<int:producto_id>', methods=['POST'])
@login_required
@modulo_requerido('productos')
def actualizar_stock_externo(producto_id):
    """Actualizar stock de producto externo (compras)"""
    if 'user_id' not in session:
        return jsonify({'error': 'No autorizado'}), 401
    
    producto = Producto.query.get_or_404(producto_id)
    
    try:
        cantidad = int(request.form['cantidad'])
        costo_compra = float(request.form.get('costo_compra', producto.costo_compra))
        
        # Actualizar stock y costo promedio
        producto.stock_actual += cantidad
        if costo_compra > 0:
            producto.costo_compra = costo_compra
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'nuevo_stock': producto.stock_actual,
            'utilidad_unitaria': producto.utilidad_unitaria,
            'margen_utilidad': round(producto.margen_utilidad, 1)
        })
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500
    
@app.route('/reporte_inventario_externo')
@login_required
@modulo_requerido('productos')
def reporte_inventario_externo():
    """Reporte completo de inventario de productos externos"""
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    productos = ProductoExterno.query.filter_by(activo=True).all()
    
    # CÃ¡lculos automÃ¡ticos
    total_valor_inventario = 0
    productos_stock_bajo = []
    
    for producto in productos:
        # Valor del inventario
        producto.valor_inventario = producto.stock_actual * producto.precio_compra
        total_valor_inventario += producto.valor_inventario
        
        # Utilidad unitaria y margen
        producto.utilidad_unitaria = producto.precio_venta - producto.precio_compra
        producto.margen_ganancia = (producto.utilidad_unitaria / producto.precio_compra * 100) if producto.precio_compra > 0 else 0
        
        # Alertas de stock bajo
        if producto.stock_actual <= producto.stock_minimo:
            productos_stock_bajo.append(producto)
    
    return render_template('reporte_inventario_externo.html',
                         productos=productos,
                         total_valor_inventario=total_valor_inventario,
                         productos_stock_bajo=productos_stock_bajo,
                         total_productos=len(productos))

@app.route('/exportar_inventario_externo')
@login_required
@modulo_requerido('productos')
def exportar_inventario_externo():
    """Exportar inventario a PDF"""
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    productos = ProductoExterno.query.filter_by(activo=True).all()
    
    from reportlab.lib.pagesizes import letter
    from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph
    from reportlab.lib import colors
    from reportlab.lib.styles import getSampleStyleSheet
    from io import BytesIO
    
    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=letter)
    elements = []
    
    # Estilos
    styles = getSampleStyleSheet()
    
    # TÃ­tulo
    title = Paragraph("Reporte de Inventario Externo", styles['Title'])
    elements.append(title)
    elements.append(Paragraph("<br/>", styles['Normal']))
    
    # Preparar datos de la tabla
    data = [['Producto', 'CategorÃ­a', 'Stock', 'Stock MÃ­n', 'Precio Compra', 
             'Precio Venta', 'Utilidad', 'Margen %', 'Valor Inv.']]
    
    for producto in productos:
        utilidad = producto.precio_venta - producto.precio_compra
        margen = (utilidad / producto.precio_compra * 100) if producto.precio_compra > 0 else 0
        valor_inventario = producto.stock_actual * producto.precio_compra
        
        data.append([
            producto.nombre,
            producto.categoria,
            str(producto.stock_actual),
            str(producto.stock_minimo),
            f"${producto.precio_compra:,.0f}",
            f"${producto.precio_venta:,.0f}",
            f"${utilidad:,.0f}",
            f"{margen:.1f}%",
            f"${valor_inventario:,.0f}"
        ])
    
    # Crear tabla
    table = Table(data)
    table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, 0), 10),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
        ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
        ('FONTSIZE', (0, 1), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.black)
    ]))
    
    elements.append(table)
    
    # Generar PDF
    doc.build(elements)
    buffer.seek(0)
    
    return Response(
        buffer.getvalue(),
        mimetype="application/pdf",
        headers={"Content-disposition": "attachment; filename=inventario_externo.pdf"}
    )
    
    
@app.route('/reporte_ventas_externas')
@login_required
@modulo_requerido('reportes')
def reporte_ventas_externas():
    """Reporte de ventas y rentabilidad de productos externos"""
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    # ParÃ¡metros de fecha (opcionales)
    fecha_inicio = request.args.get('fecha_inicio')
    fecha_fin = request.args.get('fecha_fin')
    
    # Consulta base de detalles de venta de productos externos
    query = DetalleVenta.query.join(ProductoExterno).filter(
        DetalleVenta.producto_externo_id.isnot(None)
    )
    
    # Filtrar por fechas si se proporcionan
    if fecha_inicio and fecha_fin:
        try:
            fecha_inicio = datetime.strptime(fecha_inicio, '%Y-%m-%d')
            fecha_fin = datetime.strptime(fecha_fin, '%Y-%m-%d')
            query = query.join(Venta).filter(
                Venta.fecha_hora.between(fecha_inicio, fecha_fin)
            )
        except ValueError:
            pass
    
    detalles_venta = query.all()
    
    # Procesar datos para el reporte
    ventas_por_producto = {}
    total_ventas = 0
    total_utilidad = 0
    
    for detalle in detalles_venta:
        producto = detalle.producto_externo
        if producto.id not in ventas_por_producto:
            ventas_por_producto[producto.id] = {
                'producto': producto,
                'cantidad_vendida': 0,
                'ingresos_totales': 0,
                'utilidad_total': 0
            }
        
        ventas_por_producto[producto.id]['cantidad_vendida'] += detalle.cantidad
        ventas_por_producto[producto.id]['ingresos_totales'] += detalle.cantidad * detalle.precio_unitario
        utilidad_producto = detalle.cantidad * (producto.precio_venta - producto.precio_compra)
        ventas_por_producto[producto.id]['utilidad_total'] += utilidad_producto
        
        total_ventas += detalle.cantidad * detalle.precio_unitario
        total_utilidad += utilidad_producto
    
    # Ordenar por cantidad vendida (mÃ¡s vendidos primero)
    productos_ordenados = sorted(
        ventas_por_producto.values(), 
        key=lambda x: x['cantidad_vendida'], 
        reverse=True
    )
    
    return render_template('reporte_ventas_externas.html',
                         productos_ventas=productos_ordenados,
                         total_ventas=total_ventas,
                         total_utilidad=total_utilidad,
                         fecha_inicio=fecha_inicio,
                         fecha_fin=fecha_fin)

@app.route('/exportar_ventas_externas')
@login_required
@modulo_requerido('reportes')
def exportar_ventas_externas():
    """Exportar reporte de ventas a PDF"""
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    detalles_venta = DetalleVenta.query.join(ProductoExterno).filter(
        DetalleVenta.producto_externo_id.isnot(None)
    ).all()
    
    from reportlab.lib.pagesizes import letter
    from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph
    from reportlab.lib import colors
    from reportlab.lib.styles import getSampleStyleSheet
    from io import BytesIO
    
    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=letter)
    elements = []
    
    # Estilos
    styles = getSampleStyleSheet()
    
    # TÃ­tulo
    title = Paragraph("Reporte de Ventas Externas", styles['Title'])
    elements.append(title)
    elements.append(Paragraph("<br/>", styles['Normal']))
    
    # Procesar datos
    ventas_por_producto = {}
    
    for detalle in detalles_venta:
        producto = detalle.producto_externo
        if producto.id not in ventas_por_producto:
            ventas_por_producto[producto.id] = {
                'producto': producto,
                'cantidad': 0,
                'ingresos': 0,
                'costo': 0
            }
        
        ventas_por_producto[producto.id]['cantidad'] += detalle.cantidad
        ventas_por_producto[producto.id]['ingresos'] += detalle.cantidad * detalle.precio_unitario
        ventas_por_producto[producto.id]['costo'] += detalle.cantidad * producto.precio_compra
    
    # Preparar datos de la tabla - CORREGIDO (cambiar nombre de variable)
    table_data = [['Producto', 'CategorÃ­a', 'Unidades', 'Ingresos', 'Costo', 'Utilidad', 'Margen %']]  # â† CambiÃ© 'data' por 'table_data'
    
    for venta_data in ventas_por_producto.values():  # â† CambiÃ© 'data' por 'venta_data'
        utilidad = venta_data['ingresos'] - venta_data['costo']
        margen = (utilidad / venta_data['ingresos'] * 100) if venta_data['ingresos'] > 0 else 0
        
        table_data.append([  # â† Usar 'table_data' en lugar de 'data'
            venta_data['producto'].nombre,
            venta_data['producto'].categoria,
            str(venta_data['cantidad']),
            f"${venta_data['ingresos']:,.0f}",
            f"${venta_data['costo']:,.0f}",
            f"${utilidad:,.0f}",
            f"{margen:.1f}%"
        ])
    
    # Crear tabla
    table = Table(table_data)  # â† Usar 'table_data'
    table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, 0), 10),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
        ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
        ('FONTSIZE', (0, 1), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.black)
    ]))
    
    elements.append(table)
    
    # Generar PDF
    doc.build(elements)
    buffer.seek(0)
    
    return Response(
        buffer.getvalue(),
        mimetype="application/pdf",
        headers={"Content-disposition": "attachment; filename=ventas_externas.pdf"}
    )
    
@app.route('/dashboard_externos')
@login_required
@modulo_requerido('productos')
def dashboard_externos():
    """Dashboard ejecutivo de productos externos"""
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    # MÃ©tricas generales
    total_productos = ProductoExterno.query.filter_by(activo=True).count()
    productos_stock_bajo = ProductoExterno.query.filter(
        ProductoExterno.stock_actual <= ProductoExterno.stock_minimo,
        ProductoExterno.activo == True
    ).count()
    
    # Valor total del inventario
    productos = ProductoExterno.query.filter_by(activo=True).all()
    valor_inventario = sum(p.stock_actual * p.precio_compra for p in productos)
    
    # Ventas del Ãºltimo mes
    un_mes_atras = datetime.utcnow() - timedelta(days=30)

    ventas_recientes = DetalleVenta.query.join(ProductoExterno).join(Venta).filter(
        DetalleVenta.producto_externo_id.isnot(None),
        Venta.fecha_hora >= un_mes_atras
    ).all()

    ingresos_ultimo_mes = sum(d.cantidad * d.precio_unitario for d in ventas_recientes)
    utilidad_ultimo_mes = sum(d.cantidad * (d.producto_externo.precio_venta - d.producto_externo.precio_compra) for d in ventas_recientes)

    # â† AGREGA ESTA LÃNEA FALTANTE â†“
    margen_promedio = (utilidad_ultimo_mes / ingresos_ultimo_mes * 100) if ingresos_ultimo_mes > 0 else 0

    # Productos mÃ¡s vendidos (top 5) - CORREGIDO
    top_productos = db.session.query(
        ProductoExterno,
        db.func.sum(DetalleVenta.cantidad).label('total_vendido')
    ).join(DetalleVenta).filter(
        DetalleVenta.producto_externo_id.isnot(None)
    ).group_by(ProductoExterno.id).order_by(
        db.desc('total_vendido')
    ).limit(5).all()
    
    return render_template('dashboard_externos.html',
                         total_productos=total_productos,
                         productos_stock_bajo=productos_stock_bajo,
                         valor_inventario=valor_inventario,
                         ingresos_ultimo_mes=ingresos_ultimo_mes,
                         utilidad_ultimo_mes=utilidad_ultimo_mes,
                         top_productos=top_productos,
                         margen_promedio=margen_promedio)

    
# Filtro para formatear moneda en pesos colombianos
@app.template_filter('currency')
def format_currency(value):
    """Formatear valor como moneda en pesos colombianos"""
    if value is None:
        return "$0"
    try:
        # Formato pesos colombianos: $1.234.567
        return f"${value:,.0f}".replace(",", ".")
    except (ValueError, TypeError):
        return f"${value}"

# Filtro para formatear nÃºmeros con 2 decimales
@app.template_filter('round')
def round_filter(value, decimals=2):
    """Formatear nÃºmero con decimales especÃ­ficos"""
    try:
        return round(value, decimals)
    except (ValueError, TypeError):
        return value
   
# =============================================
# RUTA DE DIAGNÃ“STICO PARA PRODUCTOS - AGREGAR ESTO
# =============================================
@app.route('/debug_api_productos')
@login_required
@modulo_requerido('sistema')
def debug_api_productos():
    """DiagnÃ³stico de la API de productos"""
    if 'user_id' not in session:
        return jsonify({'error': 'No autorizado'}), 401
    
    try:
        # Contar productos totales
        total_productos = Producto.query.count()
        
        # Productos activos
        productos_activos = Producto.query.filter_by(activo=True).all()
        
        # Productos con stock
        productos_con_stock = Producto.query.filter(Producto.stock_actual > 0).all()
        
        # Lista completa de productos
        todos_productos = Producto.query.all()
        
        productos_data = []
        for producto in todos_productos:
            # Obtener nombre de categorÃ­a de forma segura
            categoria_nombre = "Sin categorÃ­a"
            if producto.categoria_id:
                categoria = Categoria.query.get(producto.categoria_id)
                if categoria:
                    categoria_nombre = categoria.nombre
            
            productos_data.append({
                'id': producto.id,
                'nombre': producto.nombre,
                'activo': producto.activo,
                'stock_actual': producto.stock_actual,
                'precio_venta': producto.precio_venta,
                'tipo_producto': producto.tipo_producto,
                'categoria_id': producto.categoria_id,
                'categoria_nombre': categoria_nombre,
                'tiene_receta': producto.receta_id is not None
            })
        
        return jsonify({
            'estado': 'OK',
            'total_productos': total_productos,
            'productos_activos': len(productos_activos),
            'productos_con_stock': len(productos_con_stock),
            'productos': productos_data
        })
        
    except Exception as e:
        return jsonify({
            'estado': 'ERROR',
            'error': str(e)
        }), 500

# =============================================
# RUTA DE EMERGENCIA - CREAR PRODUCTOS DE PRUEBA
# =============================================
@app.route('/crear_productos_prueba')
@login_required
@modulo_requerido('sistema')
def crear_productos_prueba():
    """Crear productos de prueba si no existen"""
    if 'user_id' not in session:
        return jsonify({'error': 'No autorizado'}), 401
    
    try:
        # Verificar si ya existen productos
        if Producto.query.count() > 0:
            return jsonify({'mensaje': 'Ya existen productos en la base de datos'})
        
        # Obtener o crear categorÃ­as
        categoria_pan = Categoria.query.filter_by(nombre="PanaderÃ­a").first()
        if not categoria_pan:
            categoria_pan = Categoria(nombre="PanaderÃ­a")
            db.session.add(categoria_pan)
            db.session.flush()
        
        categoria_bebida = Categoria.query.filter_by(nombre="Bebidas").first()
        if not categoria_bebida:
            categoria_bebida = Categoria(nombre="Bebidas")
            db.session.add(categoria_bebida)
            db.session.flush()
        
        # Crear productos de prueba
        productos_prueba = [
            Producto(
                nombre="Pan Mantequilla",
                categoria_id=categoria_pan.id,
                precio_venta=3000,
                stock_actual=15,
                activo=True,
                tipo_producto='produccion'
            ),
            Producto(
                nombre="Pan Integral", 
                categoria_id=categoria_pan.id,
                precio_venta=4000,
                stock_actual=10,
                activo=True,
                tipo_producto='produccion'
            ),
            Producto(
                nombre="CafÃ© Americano",
                categoria_id=categoria_bebida.id,
                precio_venta=2000,
                stock_actual=20,
                activo=True,
                tipo_producto='externo',
                costo_compra=800
            ),
            Producto(
                nombre="Jugo de Naranja",
                categoria_id=categoria_bebida.id, 
                precio_venta=4000,
                stock_actual=12,
                activo=True,
                tipo_producto='externo',
                costo_compra=1500
            )
        ]
        
        for producto in productos_prueba:
            db.session.add(producto)
        
        db.session.commit()
        
        return jsonify({
            'mensaje': 'âœ… Productos de prueba creados exitosamente',
            'productos_creados': len(productos_prueba)
        })
        

    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500
    
# =============================================
# RUTAS PARA CIERRE DIARIO - AGREGAR ANTES DE LOS REPORTES PDF
# =============================================

@app.route('/api/cierre_diario/estado')
@login_required
@modulo_requerido('finanzas')
def estado_cierre_diario():
    """API para obtener estado actual del dÃ­a"""
    if 'user_id' not in session:
        return jsonify({'error': 'No autorizado'}), 401
    
    hoy = datetime.now().date()
    jornada = obtener_jornada_activa()
    
    # Obtener ventas del dÃ­a actual
    ventas_hoy = obtener_ventas_dia(hoy)
    total_hoy = sum(venta.total for venta in ventas_hoy)
    
    # Verificar si ya se hizo cierre hoy
    cierre_hoy = CierreDiario.query.filter_by(fecha=hoy).first()
    
    return jsonify({
        'fecha': hoy.isoformat(),
        'jornada_activa': jornada.estado == 'ACTIVA',
        'total_ventas_hoy': total_hoy,
        'total_transacciones': len(ventas_hoy),
        'cierre_realizado': cierre_hoy is not None,
        'hora_actual': datetime.now().strftime('%H:%M')
    })

@app.route('/api/cierre_diario/procesar', methods=['POST'])
@login_required
@modulo_requerido('finanzas')
def procesar_cierre_diario():
    """API para procesar el cierre diario"""
    if 'user_id' not in session:
        return jsonify({'error': 'No autorizado'}), 401
    
    try:
        cierre, mensaje = cerrar_jornada_actual()
        
        if cierre:
            return jsonify({
                'success': True,
                'mensaje': mensaje,
                'cierre': {
                    'fecha': cierre.fecha.isoformat(),
                    'total_ventas': cierre.total_ventas,
                    'total_transacciones': cierre.total_transacciones,
                    'tendencia': cierre.tendencia
                }
            })
        else:
            return jsonify({
                'success': False,
                'error': mensaje
            }), 400
            
    except Exception as e:
        return jsonify({
            'success': False,
            'error': f'Error al procesar cierre: {str(e)}'
        }), 500

@app.route('/api/cierre_diario/historial')
@login_required
@modulo_requerido('finanzas')
def historial_cierres():
    """API para obtener historial de cierres"""
    if 'user_id' not in session:
        return jsonify({'error': 'No autorizado'}), 401
    
    limite = request.args.get('limite', 30, type=int)
    cierres = obtener_historial_cierres(limite)
    
    resultado = []
    for cierre in cierres:
        resultado.append({
            'fecha': cierre.fecha.isoformat(),
            'total_ventas': cierre.total_ventas,
            'total_transacciones': cierre.total_transacciones,
            'total_efectivo': cierre.total_efectivo,
            'total_transferencia': cierre.total_transferencia,
            'total_tarjeta': cierre.total_tarjeta,
            'tendencia': cierre.tendencia,
            'productos_top': json.loads(cierre.productos_top) if cierre.productos_top else []
        })
    
    return jsonify(resultado)

@app.route('/cierre_diario')
@login_required
@modulo_requerido('finanzas')
def pagina_cierre_diario():
    """PÃ¡gina de cierre diario"""
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    hoy = datetime.now().date()
    cierre_hoy = CierreDiario.query.filter_by(fecha=hoy).first()
    ventas_hoy = obtener_ventas_dia(hoy)
    
    return render_template('cierre_diario.html',
                         cierre_hoy=cierre_hoy,
                         ventas_hoy=ventas_hoy,
                         hoy=hoy)

@app.route('/reporte/cierre_caja')
@login_required
@modulo_requerido('reportes')
def reporte_cierre_caja():
    """Reporte de cierre de caja con anÃ¡lisis automÃ¡tico - VERSIÃ“N CON ANÃLISIS POR PRODUCTO"""
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    # ðŸ†• USAR 1 FECHA SOLAMENTE + FECHAS DE COMPARACIÃ“N
    fecha_str = request.args.get('fecha', datetime.now().date().isoformat())
    
    try:
        # ðŸ†• CONVERTIR FECHA ÃšNICA
        fecha_consultada = datetime.strptime(fecha_str, '%Y-%m-%d').date()
        hoy = datetime.now().date()
        ayer = hoy - timedelta(days=1)
        
        inicio_dia = datetime.combine(fecha_consultada, datetime.min.time())
        fin_dia = datetime.combine(fecha_consultada, datetime.max.time())
        
        # ðŸ†• OBTENER panaderia_id DEL USUARIO ACTUAL
        usuario_actual = Usuario.query.get(session['user_id'])
        panaderia_id = usuario_actual.panaderia_id
        
        print(f"ðŸ” DEBUG: Generando reporte para panaderia_id: {panaderia_id}")
        print(f"ðŸ“… Fecha consultada: {fecha_consultada}")
        print(f"ðŸ“… Rango: {inicio_dia} a {fin_dia}")
        
        # ðŸ†• DEBUG: VER TODAS LAS VENTAS EN LA BD (SIN FILTROS)
        print("ðŸ”Ž DEBUG - TODAS las ventas en la BD:")
        todas_ventas = Venta.query.all()
        for v in todas_ventas:
            print(f"   Venta ID: {v.id}, Fecha: {v.fecha_hora}, PanaderÃ­a: {v.panaderia_id}, Total: ${v.total}")
        
        # ðŸ†• CONSULTAS CON FILTRO MULTICLIENTE
        ventas_dia = Venta.query.filter(
            db.func.date(Venta.fecha_hora) == fecha_consultada,  # ðŸŽ¯ SOLO POR FECHA
            Venta.panaderia_id == panaderia_id
        ).all()
        
        print(f"ðŸ“Š Ventas encontradas con filtros: {len(ventas_dia)}")
        for v in ventas_dia:
            print(f"   âœ… Venta encontrada: ID {v.id}, Fecha: {v.fecha_hora}, Total: ${v.total}")
        
        # ðŸŽ SEPARAR VENTAS NORMALES VS DONACIONES
        ventas_normales = [v for v in ventas_dia if not v.es_donacion]
        donaciones = [v for v in ventas_dia if v.es_donacion]
        
        print(f"ðŸ’° Ventas normales: {len(ventas_normales)}")
        print(f"ðŸŽ Donaciones: {len(donaciones)}")
        
        # ðŸŽ CALCULAR MÃ‰TRICAS SEPARADAS
        total_ventas_normales = sum(venta.total for venta in ventas_normales)
        total_transacciones = len(ventas_dia)
        
        print(f"ðŸ’µ Total ventas normales: ${total_ventas_normales}")
        print(f"ðŸ”¢ Total transacciones: {total_transacciones}")
        
        # Calcular mÃ©tricas por mÃ©todo de pago (SOLO VENTAS NORMALES)
        ventas_por_metodo = {}
        for venta in ventas_normales:
            if venta.metodo_pago not in ventas_por_metodo:
                ventas_por_metodo[venta.metodo_pago] = 0
            ventas_por_metodo[venta.metodo_pago] += venta.total
        
        print(f"ðŸ’³ Ventas por mÃ©todo: {ventas_por_metodo}")
        
        # ðŸ†• OBTENER COMPARATIVA CON DÃA ANTERIOR
        dia_anterior = fecha_consultada - timedelta(days=1)
        ventas_dia_anterior = Venta.query.filter(
            db.func.date(Venta.fecha_hora) == dia_anterior,
            Venta.panaderia_id == panaderia_id  # ðŸŽ¯ FILTRO MULTICLIENTE
        ).all()
        
        ventas_dia_anterior_normales = [v for v in ventas_dia_anterior if not v.es_donacion]
        total_dia_anterior = sum(venta.total for venta in ventas_dia_anterior_normales)
        
        # Calcular tendencia
        if total_dia_anterior > 0:
            tendencia = ((total_ventas_normales - total_dia_anterior) / total_dia_anterior) * 100
        else:
            tendencia = 100 if total_ventas_normales > 0 else 0
        
        print(f"ðŸ“ˆ Tendencia: {tendencia}%")
        
        # ðŸ†• PRODUCTOS MÃS VENDIDOS (INCLUYENDO DONACIONES)
        detalles_dia = DetalleVenta.query.join(Venta).filter(
            Venta.fecha_hora >= inicio_dia,
            Venta.fecha_hora <= fin_dia,
            Venta.panaderia_id == panaderia_id  # ðŸŽ¯ FILTRO MULTICLIENTE
        ).all()
        
        print(f"ðŸ“¦ Detalles de venta encontrados: {len(detalles_dia)}")
        
        productos_vendidos = {}
        for detalle in detalles_dia:
            if detalle.producto:
                nombre = detalle.producto.nombre
            elif detalle.producto_externo:
                nombre = detalle.producto_externo.nombre
            else:
                continue
                
            if nombre not in productos_vendidos:
                productos_vendidos[nombre] = 0
            productos_vendidos[nombre] += detalle.cantidad
        
        productos_top = sorted(productos_vendidos.items(), key=lambda x: x[1], reverse=True)[:5]
        
        # ðŸŽ¯ --- INICIO: MÃ‰TRICAS FINANCIERAS CON COSTOS REALES ---
        print("ðŸ’° CALCULANDO MÃ‰TRICAS FINANCIERAS CON COSTOS REALES...")
        
        # ðŸŽ¯ 1. CALCULAR COSTOS E INGRESOS CON FUENTES REALES
        costo_total_inventario = 0
        ingresos_totales = 0
        total_productos_vendidos = 0

        # ðŸ†• VARIABLES PARA ANÃLISIS POR PRODUCTO
        ingresos_por_producto = {}
        costos_por_producto = {}
        utilidades_por_producto = {}

        # ðŸ†• NUEVAS VARIABLES PARA PRODUCTOS SEPARADOS
        productos_vendidos_lista = []
        productos_donados_detalle = []

        # ðŸ†• CONTADORES CORREGIDOS PARA DONACIONES
        total_unidades_donadas = 0
        total_productos_donados_unicos = 0

        for detalle in detalles_dia:
            # ðŸŽ¯ OBTENER PRECIO DE COSTO CON FUENTES REALES
            precio_costo = 0
            fuente_costo = "No identificada"
            
            if detalle.producto:
                # ðŸ“¦ PRODUCTO DE PANADERÃA CON RECETA
                producto = detalle.producto
                if producto.receta and hasattr(producto.receta, 'costo_unitario') and producto.receta.costo_unitario:
                    # ðŸŽ¯ USAR COSTO UNITARIO REAL DE LA RECETA
                    precio_costo = producto.receta.costo_unitario
                    fuente_costo = "receta.costo_unitario (real)"
                    print(f"âœ… Producto {producto.nombre} - Costo real: ${precio_costo} desde receta")
                    
                elif hasattr(producto, 'costo_compra') and producto.costo_compra:
                    precio_costo = producto.costo_compra
                    fuente_costo = "producto.costo_compra"
                else:
                    # EstimaciÃ³n de reserva
                    precio_costo = detalle.precio_unitario * 0.4
                    fuente_costo = "estimaciÃ³n (40%)"
                    
            elif detalle.producto_externo:
                # ðŸ¥¤ PRODUCTO EXTERNO
                producto = detalle.producto_externo
                precio_costo = producto.precio_compra if hasattr(producto, 'precio_compra') else 0
                fuente_costo = "producto_externo.precio_compra"
            
            # ðŸŽ¯ CALCULAR COSTO TOTAL Y INGRESOS
            costo_detalle = precio_costo * detalle.cantidad
            ingreso_detalle = detalle.precio_unitario * detalle.cantidad
            
            costo_total_inventario += costo_detalle
            ingresos_totales += ingreso_detalle
            total_productos_vendidos += detalle.cantidad
            
            # ðŸ†• ACUMULAR POR PRODUCTO PARA ANÃLISIS DETALLADO
            if detalle.producto:
                nombre_producto = detalle.producto.nombre
            else:
                nombre_producto = detalle.producto_externo.nombre
            
            if nombre_producto not in ingresos_por_producto:
                ingresos_por_producto[nombre_producto] = 0
                costos_por_producto[nombre_producto] = 0
                utilidades_por_producto[nombre_producto] = 0
            
            ingresos_por_producto[nombre_producto] += ingreso_detalle
            costos_por_producto[nombre_producto] += costo_detalle
            utilidades_por_producto[nombre_producto] += (ingreso_detalle - costo_detalle)
            
            # ðŸ†• SEPARAR PRODUCTOS VENDIDOS VS DONADOS
            es_donacion = detalle.venta.es_donacion if detalle.venta else False
            
            if not es_donacion:
                # PRODUCTO VENDIDO (GENERA INGRESOS REALES)
                productos_vendidos_lista.append({
                    'nombre': nombre_producto,
                    'cantidad': detalle.cantidad,
                    'ingresos': ingreso_detalle,
                    'costo': costo_detalle,
                    'utilidad': ingreso_detalle - costo_detalle,
                    'margen': ((ingreso_detalle - costo_detalle) / ingreso_detalle * 100) if ingreso_detalle > 0 else 0
                })
            else:
                # PRODUCTO DONADO (NO GENERA INGRESOS REALES)
                productos_donados_detalle.append({
                    'nombre': nombre_producto,
                    'cantidad': detalle.cantidad,
                    'valor_mercado': ingreso_detalle,  # Valor que habrÃ­a generado
                    'costo_real': costo_detalle  # Costo real de producciÃ³n
                })
                # ðŸ†• CONTAR UNIDADES DONADAS
                total_unidades_donadas += detalle.cantidad
            
            # Debug detallado
            print(f"   ðŸ“Š {nombre_producto} - Cant: {detalle.cantidad} - Precio: ${detalle.precio_unitario} - Costo: ${precio_costo} - Fuente: {fuente_costo} - DonaciÃ³n: {es_donacion}")

        print(f"ðŸ“¦ Costo total inventario: ${costo_total_inventario:.0f}")
        print(f"ðŸ’° Ingresos totales: ${ingresos_totales:.0f}")
        print(f"ðŸŽ¯ Total productos vendidos: {total_productos_vendidos}")

        # ðŸŽ¯ 2. CALCULAR MARGEN PROMEDIO CON COSTOS REALES (SOLO VENTAS NORMALES)
        ingresos_ventas_normales = sum(item['ingresos'] for item in productos_vendidos_lista)
        costos_ventas_normales = sum(item['costo'] for item in productos_vendidos_lista)
        
        if ingresos_ventas_normales > 0:
            margen_promedio = ((ingresos_ventas_normales - costos_ventas_normales) / ingresos_ventas_normales) * 100
        else:
            margen_promedio = 0

        # ðŸŽ¯ 3. CALCULAR UTILIDAD NETA REAL (SOLO VENTAS NORMALES)
        utilidad_neta = ingresos_ventas_normales - costos_ventas_normales

        # ðŸŽ¯ 4. CALCULAR TICKET PROMEDIO
        transacciones_normales = len(ventas_normales)
        if transacciones_normales > 0:
            ticket_promedio = total_ventas_normales / transacciones_normales
        else:
            ticket_promedio = 0

        # ðŸŽ¯ 5. CALCULAR PRODUCTOS POR VENTA
        if transacciones_normales > 0:
            productos_por_venta = total_productos_vendidos / transacciones_normales
        else:
            productos_por_venta = 0

        print(f"ðŸ“ˆ Margen promedio REAL: {margen_promedio:.1f}%")
        print(f"ðŸ’µ Utilidad neta REAL: ${utilidad_neta:.0f}")
        print(f"ðŸŽ« Ticket promedio: ${ticket_promedio:.0f}")
        print(f"ðŸ“¦ Productos por venta: {productos_por_venta:.1f}")
        
        # ðŸ†• AGRUPAR PRODUCTOS VENDIDOS POR NOMBRE
        productos_vendidos_agrupados = {}
        for producto in productos_vendidos_lista:
            nombre = producto['nombre']
            if nombre not in productos_vendidos_agrupados:
                productos_vendidos_agrupados[nombre] = {
                    'nombre': nombre,
                    'cantidad': 0,
                    'ingresos': 0,
                    'costo': 0,
                    'utilidad': 0
                }
            
            productos_vendidos_agrupados[nombre]['cantidad'] += producto['cantidad']
            productos_vendidos_agrupados[nombre]['ingresos'] += producto['ingresos']
            productos_vendidos_agrupados[nombre]['costo'] += producto['costo']
            productos_vendidos_agrupados[nombre]['utilidad'] += producto['utilidad']
        
        # CALCULAR MARGEN PARA CADA PRODUCTO AGRUPADO
        for producto in productos_vendidos_agrupados.values():
            if producto['ingresos'] > 0:
                producto['margen'] = (producto['utilidad'] / producto['ingresos']) * 100
            else:
                producto['margen'] = 0
        
        productos_vendidos_final = list(productos_vendidos_agrupados.values())
        
        # ðŸ†• AGRUPAR PRODUCTOS DONADOS POR NOMBRE
        productos_donados_agrupados = {}
        for producto in productos_donados_detalle:
            nombre = producto['nombre']
            if nombre not in productos_donados_agrupados:
                productos_donados_agrupados[nombre] = {
                    'nombre': nombre,
                    'cantidad': 0,
                    'valor_mercado': 0,
                    'costo_real': 0
                }
            
            productos_donados_agrupados[nombre]['cantidad'] += producto['cantidad']
            productos_donados_agrupados[nombre]['valor_mercado'] += producto['valor_mercado']
            productos_donados_agrupados[nombre]['costo_real'] += producto['costo_real']
        
        productos_donados_final = list(productos_donados_agrupados.values())
        
        # ðŸ†• CALCULAR TOTALES CORREGIDOS PARA DONACIONES
        total_productos_donados_unicos = len(productos_donados_final)
        total_unidades_donadas = sum(item['cantidad'] for item in productos_donados_final)
        valor_total_donaciones = sum(item['valor_mercado'] for item in productos_donados_final)
        
        print(f"ðŸ†• PRODUCTOS VENDIDOS: {len(productos_vendidos_final)} productos Ãºnicos")
        for producto in productos_vendidos_final[:3]:
            print(f"   ðŸ’° {producto['nombre']} - Cant: {producto['cantidad']} - Ingresos: ${producto['ingresos']:.0f} - Utilidad: ${producto['utilidad']:.0f}")
        
        print(f"ðŸ†• PRODUCTOS DONADOS: {total_productos_donados_unicos} productos Ãºnicos, {total_unidades_donadas} unidades totales")
        for producto in productos_donados_final[:3]:
            print(f"   ðŸŽ {producto['nombre']} - Cant: {producto['cantidad']} - Valor: ${producto['valor_mercado']:.0f} - Costo: ${producto['costo_real']:.0f}")
        
        # ðŸŽ DATOS DE DONACIONES CORREGIDOS
        total_donaciones = len(donaciones)  # NÃºmero de transacciones de donaciÃ³n
        productos_donados = total_unidades_donadas  # NÃºmero total de unidades donadas
        
        print(f"ðŸ’° Valor total donaciones: ${valor_total_donaciones}")
        print(f"ðŸŽ Transacciones de donaciÃ³n: {total_donaciones}")
        print(f"ðŸ“¦ Unidades donadas totales: {productos_donados}")
        
        # ðŸ†• PREPARAR VENTAS DETALLADAS PARA TABLA
        ventas_detalladas = []
        for venta in ventas_dia:
            cantidad_productos = sum(detalle.cantidad for detalle in venta.detalles)
            ventas_detalladas.append({
                'id': venta.id,
                'fecha_hora': venta.fecha_hora,
                'metodo_pago': venta.metodo_pago,
                'total': venta.total,
                'es_donacion': venta.es_donacion,
                'cantidad_productos': cantidad_productos
            })
        
        print(f"âœ… Reporte generado exitosamente")
        print(f"ðŸŽ Total donaciones (transacciones): {total_donaciones}")
        print(f"ðŸ“¦ Productos donados (unidades): {productos_donados}")
        print(f"ðŸ’° Valor donaciones: ${valor_total_donaciones}")
        
        # ðŸ†• ENVIAR DATOS COMPLETOS AL TEMPLATE
        return render_template('cierre_caja.html',
                            fecha=fecha_consultada,
                            hoy=hoy,
                            ayer=ayer,
                            es_hoy=(fecha_consultada == hoy),
                            total_ventas=total_ventas_normales,
                            ventas_por_metodo=ventas_por_metodo,
                            tendencia=tendencia,
                            total_dia_anterior=total_dia_anterior,
                            productos_top=productos_top,
                            total_transacciones=total_transacciones,
                            total_donaciones=total_donaciones,
                            productos_donados=productos_donados,  # ðŸ†• AHORA ES UNIDADES, NO TRANSACCIONES
                            # ðŸ†• NUEVAS VARIABLES REQUERIDAS
                            valor_total_donaciones=valor_total_donaciones,
                            ventas_detalladas=ventas_detalladas,
                            # ðŸŽ¯ MÃ‰TRICAS FINANCIERAS CON COSTOS REALES
                            ticket_promedio=ticket_promedio,
                            productos_por_venta=productos_por_venta,
                            margen_promedio=margen_promedio,
                            costo_inventario=costo_total_inventario,
                            utilidad_neta=utilidad_neta,
                            # ðŸ†• ANÃLISIS POR PRODUCTO
                            ingresos_por_producto=ingresos_por_producto,
                            costos_por_producto=costos_por_producto,
                            utilidades_por_producto=utilidades_por_producto,
                            # ðŸ†• NUEVAS VARIABLES PARA PDF SEPARADO
                            productos_vendidos=productos_vendidos_final,
                            productos_donados_detalle=productos_donados_final)
                            
    
    except Exception as e:
        print(f"âŒ ERROR en reporte_cierre_caja: {str(e)}")
        flash(f'Error generando reporte: {str(e)}', 'error')
        return redirect(url_for('dashboard'))
    
@app.route('/reporte/ventas')
@login_required
@modulo_requerido('reportes')
def reporte_ventas():
    """Reporte de ventas por perÃ­odo con anÃ¡lisis predictivo"""
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    # Obtener parÃ¡metros de fecha o usar valores por defecto
    fecha_inicio_str = request.args.get('fecha_inicio')
    fecha_fin_str = request.args.get('fecha_fin')
    periodo = request.args.get('periodo', 'semana')  # Cambiado a 'semana' como default
    
    hoy = datetime.now().date()
    
    if fecha_inicio_str and fecha_fin_str:
        # Usar fechas proporcionadas por el usuario
        fecha_inicio = datetime.strptime(fecha_inicio_str, '%Y-%m-%d').date()
        fecha_fin = datetime.strptime(fecha_fin_str, '%Y-%m-%d').date()
        periodo = 'personalizado'
    else:
        # Valores por defecto (Ãºltimos 7 dÃ­as)
        fecha_fin = hoy
        fecha_inicio = fecha_fin - timedelta(days=7)
        periodo = 'semana'
    
    # Validar que fecha_inicio no sea mayor que fecha_fin
    if fecha_inicio > fecha_fin:
        flash('La fecha de inicio no puede ser mayor que la fecha fin', 'error')
        fecha_inicio = fecha_fin - timedelta(days=7)
    
    # Obtener ventas del perÃ­odo (INCLUYENDO DONACIONES)
    ventas_periodo = Venta.query.filter(
        db.func.date(Venta.fecha_hora) >= fecha_inicio,
        db.func.date(Venta.fecha_hora) <= fecha_fin
    ).all()
    
    # ðŸŽ SEPARAR VENTAS NORMALES VS DONACIONES
    ventas_normales = [v for v in ventas_periodo if not v.es_donacion]
    donaciones = [v for v in ventas_periodo if v.es_donacion]
    
    # ðŸŽ CALCULAR MÃ‰TRICAS SEPARADAS
    total_ventas_normales = sum(venta.total for venta in ventas_normales)
    total_transacciones = len(ventas_periodo)  # Incluye donaciones
    
    # Calcular mÃ©tricas avanzadas (SOLO VENTAS NORMALES)
    total_ventas = total_ventas_normales
    promedio_venta = total_ventas_normales / len(ventas_normales) if ventas_normales else 0
    
    # AnÃ¡lisis de tendencia usando ML (SOLO VENTAS NORMALES)
    tendencia = calcular_tendencia_ventas(fecha_inicio, fecha_fin)
    
    # Productos mÃ¡s vendidos del perÃ­odo (INCLUYENDO DONACIONES)
    detalles_periodo = DetalleVenta.query.join(Venta).filter(
        db.func.date(Venta.fecha_hora) >= fecha_inicio,
        db.func.date(Venta.fecha_hora) <= fecha_fin
    ).all()
    
    productos_analisis = analizar_productos_periodo(detalles_periodo)
    
    # ðŸŽ DATOS DE DONACIONES PARA EL TEMPLATE
    total_donaciones = len(donaciones)
    productos_donados = sum(len(v.detalles) for v in donaciones)
    
    return render_template('ventas_periodo.html',
                         periodo=periodo,
                         fecha_inicio=fecha_inicio,
                         fecha_fin=fecha_fin,
                         total_ventas=total_ventas_normales,  # Solo ventas normales
                         promedio_venta=promedio_venta,
                         tendencia=tendencia,
                         productos_analisis=productos_analisis,
                         total_transacciones=total_transacciones,
                         datetime=datetime,  # AÃ±adido para usar en templates
                         # ðŸŽ NUEVOS DATOS
                         total_donaciones=total_donaciones,
                         productos_donados=productos_donados)

@app.route('/reporte/productos_populares')
@login_required
@modulo_requerido('reportes')
def reporte_productos_populares():
    """Reporte de productos mÃ¡s vendidos con anÃ¡lisis de rotaciÃ³n"""
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    # Obtener parÃ¡metros de fecha o usar valores por defecto
    fecha_inicio_str = request.args.get('fecha_inicio')
    fecha_fin_str = request.args.get('fecha_fin')
    
    if fecha_inicio_str and fecha_fin_str:
        # Usar fechas proporcionadas por el usuario
        fecha_inicio = datetime.strptime(fecha_inicio_str, '%Y-%m-%d').date()
        fecha_fin = datetime.strptime(fecha_fin_str, '%Y-%m-%d').date()
    else:
        # Valores por defecto (Ãºltimos 30 dÃ­as)
        fecha_fin = datetime.now().date()
        fecha_inicio = fecha_fin - timedelta(days=30)
    
    # Actualizar rotaciones automÃ¡ticas antes de generar reporte
    actualizaciones = actualizar_rotaciones_automaticas()
    
    # Obtener productos mÃ¡s vendidos del perÃ­odo (INCLUYENDO DONACIONES)
    detalles = DetalleVenta.query.join(Venta).filter(
        Venta.fecha_hora >= fecha_inicio,
        Venta.fecha_hora <= fecha_fin
    ).all()
    
    # Analizar productos (INCLUYENDO DONACIONES)
    analisis_productos = {}
    
    for detalle in detalles:
        if detalle.producto:
            producto_id = detalle.producto.id
            nombre = detalle.producto.nombre
            tipo = 'ProducciÃ³n'
        elif detalle.producto_externo:
            producto_id = detalle.producto_externo.id
            nombre = detalle.producto_externo.nombre
            tipo = 'Externo'
        else:
            continue
        
        if producto_id not in analisis_productos:
            analisis_productos[producto_id] = {
                'nombre': nombre,
                'tipo': tipo,
                'cantidad_vendida': 0,
                'ingresos_totales': 0,
                'rotacion_promedio': 0
            }
        
        analisis_productos[producto_id]['cantidad_vendida'] += detalle.cantidad
        # ðŸŽ LOS INGRESOS SE CALCULAN NORMALMENTE (las donaciones ya tienen total=0)
        analisis_productos[producto_id]['ingresos_totales'] += detalle.cantidad * detalle.precio_unitario
    
    # Ordenar por cantidad vendida
    productos_ordenados = sorted(analisis_productos.values(), 
                               key=lambda x: x['cantidad_vendida'], 
                               reverse=True)
    
    # Agregar datos de rotaciÃ³n automÃ¡tica
    for producto in productos_ordenados[:20]:  # Top 20
        rotacion = calcular_rotacion_automatica_por_nombre(producto['nombre'])
        producto['rotacion_promedio'] = rotacion
    
    # ðŸŽ OBTENER DATOS DE DONACIONES PARA EL PERÃODO
    ventas_periodo = Venta.query.filter(
        Venta.fecha_hora >= fecha_inicio,
        Venta.fecha_hora <= fecha_fin
    ).all()
    
    donaciones = [v for v in ventas_periodo if v.es_donacion]
    total_donaciones = len(donaciones)
    productos_donados = sum(len(v.detalles) for v in donaciones)
    
    return render_template('productos_populares.html',
                         productos=productos_ordenados[:20],
                         fecha_inicio=fecha_inicio,
                         fecha_fin=fecha_fin,
                         actualizaciones_ml=actualizaciones,
                         datetime=datetime,  # â† Â¡ESTO ES LO QUE FALTA!
                         # ðŸŽ NUEVOS DATOS
                         total_donaciones=total_donaciones,
                         productos_donados=productos_donados)

@app.route('/reporte/analisis_predictivo')
@login_required
@modulo_requerido('reportes')
def reporte_analisis_predictivo():
    """Reporte de anÃ¡lisis predictivo con recomendaciones ML"""
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    # Obtener datos para anÃ¡lisis predictivo
    productos_analisis = []
    recetas_activas = Receta.query.filter_by(activo=True).all()
    
    for receta in recetas_activas:
        if receta.producto:
            # Calcular proyecciones usando ML (INCLUYENDO DONACIONES EN DATOS HISTÃ“RICOS)
            proyeccion = calcular_proyeccion_ventas(receta.producto.id)
            productos_analisis.append({
                'producto': receta.producto.nombre,
                'stock_actual': receta.producto.stock_actual,
                'rotacion_actual': proyeccion.get('rotacion_actual', 0),
                'proyeccion_ventas': proyeccion.get('proyeccion', 0),
                'dias_stock': proyeccion.get('dias_stock', 0),
                'recomendacion': generar_recomendacion_stock(receta.producto.id, proyeccion),
                'nivel_riesgo': proyeccion.get('nivel_riesgo', 'BAJO')
            })
    
    # Alertas inteligentes
    alertas = generar_alertas_inteligentes()
    
    # ðŸŽ OBTENER DATOS DE DONACIONES RECIENTES (ÃšLTIMOS 30 DÃAS)
    fecha_inicio = datetime.now().date() - timedelta(days=30)
    donaciones_recientes = Venta.query.filter(
        Venta.fecha_hora >= fecha_inicio,
        Venta.es_donacion == True
    ).all()
    
    total_donaciones_30dias = len(donaciones_recientes)
    productos_donados_30dias = sum(len(v.detalles) for v in donaciones_recientes)
    
    return render_template('analisis_predictivo.html',
                     productos_analisis=productos_analisis,
                     alertas=alertas,
                     fecha_analisis=datetime.now().date(),
                     datetime=datetime,  # Â¡Importante! Pasar datetime al template
                     # ðŸŽ NUEVOS DATOS
                     total_donaciones=total_donaciones_30dias,
                     productos_donados=productos_donados_30dias)
    

# (aquÃ­ termina reporte_analisis_predictivo)


# ðŸ†• NUEVA FUNCIÃ“N - INSERTAR AQUÃ
@app.route('/reporte/ventas_avanzado')
@login_required
@modulo_requerido('reportes')
def reporte_ventas_avanzado():
    """Reporte unificado: Ventas por perÃ­odo + AnÃ¡lisis Predictivo + ML"""
    
    # ðŸŽ¯ VERIFICAR SESIÃ“N
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    # ðŸŽ¯ OBTENER PARÃMETROS DE FECHA (COMÃšN A AMBOS REPORTES)
    fecha_inicio_str = request.args.get('fecha_inicio')
    fecha_fin_str = request.args.get('fecha_fin')
    periodo = request.args.get('periodo', 'semana_actual')
    
    # ðŸŽ¯ OBTENER FECHAS CON VALORES POR DEFECTO
    hoy = datetime.now().date()
    
    if fecha_inicio_str and fecha_fin_str:
        fecha_inicio = datetime.strptime(fecha_inicio_str, '%Y-%m-%d').date()
        fecha_fin = datetime.strptime(fecha_fin_str, '%Y-%m-%d').date()
        periodo = 'personalizado'
    else:
        # Por defecto: esta semana
        fecha_fin = hoy
        fecha_inicio = fecha_fin - timedelta(days=fecha_fin.weekday())  # Inicio de semana (lunes)
        periodo = 'semana_actual'
    
    # ðŸŽ¯ VALIDACIÃ“N DE FECHAS
    if fecha_inicio > fecha_fin:
        flash('âŒ La fecha de inicio no puede ser mayor que la fecha fin', 'error')
        fecha_inicio = fecha_fin - timedelta(days=7)
    
    # ðŸŽ¯ OBTENER panaderia_id DEL USUARIO ACTUAL (MULTICLIENTE)
    usuario_actual = Usuario.query.get(session['user_id'])
    panaderia_id = usuario_actual.panaderia_id
    
    print(f"ðŸ” [VENTAS_AVANZADO] Usuario: {usuario_actual.username}, PanaderÃ­a: {panaderia_id}")
    print(f"ðŸ“… PerÃ­odo: {fecha_inicio} a {fecha_fin}")
    
    # =====================================================================
    # ðŸ“Š SECCIÃ“N 1: DATOS DE VENTAS REALES
    # =====================================================================
    
    # ðŸŽ¯ OBTENER VENTAS DEL PERÃODO (INCLUYENDO DONACIONES)
    ventas_periodo = Venta.query.filter(
        db.func.date(Venta.fecha_hora) >= fecha_inicio,
        db.func.date(Venta.fecha_hora) <= fecha_fin,
        Venta.panaderia_id == panaderia_id  # ðŸŽ¯ FILTRO MULTICLIENTE
    ).all()
    
    # ðŸŽ SEPARAR VENTAS NORMALES VS DONACIONES
    ventas_normales = [v for v in ventas_periodo if not v.es_donacion]
    donaciones = [v for v in ventas_periodo if v.es_donacion]
    
    # ðŸŽ¯ CALCULAR MÃ‰TRICAS BÃSICAS DE VENTAS
    total_ventas_normales = sum(venta.total for venta in ventas_normales)
    total_transacciones = len(ventas_periodo)
    
    # ðŸŽ¯ CALCULAR PROMEDIO DE VENTA (SOLO VENTAS NORMALES)
    promedio_venta = total_ventas_normales / len(ventas_normales) if ventas_normales else 0
    
    # ðŸŽ DATOS DE DONACIONES
    total_donaciones = len(donaciones)
    productos_donados = sum(len(v.detalles) for v in donaciones)
    
    print(f"ðŸ’° Ventas: ${total_ventas_normales:.2f}, Transacciones: {total_transacciones}")
    
    # =====================================================================
    # ðŸ“ˆ NUEVOS CÃLCULOS PARA GRÃFICOS Y DATOS REALES
    # =====================================================================
    
    # ðŸŽ¯ TOP 5 PRODUCTOS MÃS VENDIDOS (REALES - CON VALIDACIÃ“N)
    from collections import Counter
    productos_vendidos = []
    
    for venta in ventas_normales:
        for item in venta.detalles:
            # âœ… VALIDAR QUE EL PRODUCTO NO SEA None - ESTO EVITA EL ERROR
            if item.producto is not None:
                productos_vendidos.append({
                    'nombre': item.producto.nombre,
                    'cantidad': item.cantidad,
                    'categoria': getattr(item.producto, 'categoria', 'Sin CategorÃ­a')
                })
            else:
                print(f"âš ï¸  DetalleVenta {item.id} tiene producto None, omitiendo...")
    
    # Contar productos mÃ¡s vendidos
    contador_productos = Counter()
    for producto in productos_vendidos:
        contador_productos[producto['nombre']] += producto['cantidad']
    
    # Obtener top 5 productos (o menos si no hay suficientes)
    top_5_productos = contador_productos.most_common(5)
    top_productos_labels = [producto[0] for producto in top_5_productos]
    top_productos_data = [producto[1] for producto in top_5_productos]
    
    # ðŸŽ¯ DISTRIBUCIÃ“N POR CATEGORÃA
    categorias_counter = Counter()
    for producto in productos_vendidos:
        categoria = producto['categoria']
        categorias_counter[categoria] += producto['cantidad']
    
    categorias_labels = list(categorias_counter.keys())
    categorias_data = list(categorias_counter.values())
    
    # ðŸŽ¯ TENDENCIA DIARIA DE VENTAS
    ventas_por_dia = {}
    for venta in ventas_normales:
        fecha = venta.fecha_hora.date()
        ventas_por_dia[fecha] = ventas_por_dia.get(fecha, 0) + venta.total
    
    # Ordenar por fecha y llenar vacÃ­os
    todas_fechas = []
    fecha_actual = fecha_inicio
    while fecha_actual <= fecha_fin:
        todas_fechas.append(fecha_actual)
        fecha_actual += timedelta(days=1)
    
    tendencia_labels = [fecha.strftime('%d/%m') for fecha in todas_fechas]
    tendencia_data = [ventas_por_dia.get(fecha, 0) for fecha in todas_fechas]
    
    # ðŸŽ¯ CÃLCULO DE TENDENCIA vs PERÃODO ANTERIOR
    periodo_anterior_inicio = fecha_inicio - (fecha_fin - fecha_inicio)
    periodo_anterior_fin = fecha_inicio - timedelta(days=1)
    
    ventas_periodo_anterior = Venta.query.filter(
        Venta.panaderia_id == panaderia_id,
        db.func.date(Venta.fecha_hora) >= periodo_anterior_inicio,
        db.func.date(Venta.fecha_hora) <= periodo_anterior_fin,
        Venta.es_donacion == False
    ).all()
    
    total_ventas_anterior = sum(v.total for v in ventas_periodo_anterior)
    
    if total_ventas_anterior > 0:
        tendencia_porcentaje = ((total_ventas_normales - total_ventas_anterior) / total_ventas_anterior * 100)
    else:
        tendencia_porcentaje = 100 if total_ventas_normales > 0 else 0
    
    # ðŸŽ¯ PORCENTAJES VENTAS VS DONACIONES
    porcentaje_ventas = 100 - (total_donaciones / total_transacciones * 100) if total_transacciones > 0 else 100
    porcentaje_donaciones = (total_donaciones / total_transacciones * 100) if total_transacciones > 0 else 0
    
    # =====================================================================
    # ðŸ¤– SECCIÃ“N 2: ANÃLISIS ML (MANTENIENDO TU LÃ“GICA EXISTENTE)
    # =====================================================================
    
    # ðŸŽ¯ TENDENCIA (usando tu funciÃ³n existente)
    try:
        tendencia_ml = calcular_tendencia_ventas(fecha_inicio, fecha_fin)
        print(f"ðŸ“ˆ Tendencia ML: {tendencia_ml:.1f}%")
    except Exception as e:
        print(f"âš ï¸  Error en tendencia ML: {e}")
        tendencia_ml = tendencia_porcentaje  # Usar cÃ¡lculo alternativo
    
    # ðŸŽ¯ ALERTAS INTELIGENTES
    try:
        alertas = generar_alertas_inteligentes()
        print(f"ðŸ”” Alertas: {len(alertas)}")
    except Exception as e:
        print(f"âš ï¸  Error en alertas: {e}")
        alertas = []
    
    # ðŸŽ¯ ANÃLISIS DE PRODUCTOS
    try:
        detalles_periodo = DetalleVenta.query.join(Venta).filter(
            db.func.date(Venta.fecha_hora) >= fecha_inicio,
            db.func.date(Venta.fecha_hora) <= fecha_fin,
            Venta.panaderia_id == panaderia_id
        ).all()
        
        productos_analisis = analizar_productos_periodo(detalles_periodo)
        print(f"ðŸ“¦ Productos analizados: {len(productos_analisis)}")
    except Exception as e:
        print(f"âš ï¸  Error en anÃ¡lisis productos: {e}")
        productos_analisis = {}
    
    # ðŸŽ¯ PROYECCIONES ML (POR AHORA VACÃO)
    productos_analisis_ml = []
    
    # ðŸŽ¯ GENERAR RECOMENDACIONES BASADAS EN DATOS REALES
    recomendaciones = []
    if top_5_productos:
        recomendaciones.append(f"Aumentar producciÃ³n de '{top_5_productos[0][0]}' en 20%")
    if tendencia_porcentaje > 50:
        recomendaciones.append("Mantener estrategia comercial actual - crecimiento excelente")
    elif tendencia_porcentaje < 0:
        recomendaciones.append("Revisar estrategia comercial - tendencia negativa detectada")
    
    if len(ventas_normales) > 0:
        # AnÃ¡lisis de horarios pico
        ventas_por_hora = Counter()
        for venta in ventas_normales:
            hora = venta.fecha_hora.hour
            ventas_por_hora[hora] += 1
        
        if ventas_por_hora:
            hora_pico = ventas_por_hora.most_common(1)[0][0]
            recomendaciones.append(f"Optimizar personal para horario pico: {hora_pico}:00")
    
    print(f"âœ… [VENTAS_AVANZADO] Reporte generado exitosamente")
    print(f"ðŸ“Š Productos en top: {len(top_productos_labels)}, CategorÃ­as: {len(categorias_labels)}")
    
    # =====================================================================
    # ðŸŽ¯ RENDERIZAR TEMPLATE UNIFICADO CON TODOS LOS DATOS
    # =====================================================================
    return render_template('ventas_avanzado.html',
                         # Fechas y perÃ­odo
                         periodo=periodo,
                         fecha_inicio=fecha_inicio,
                         fecha_fin=fecha_fin,
                         
                         # MÃ©tricas principales (manteniendo compatibilidad)
                         total_ventas=total_ventas_normales,
                         promedio_venta=promedio_venta,
                         total_transacciones=total_transacciones,
                         total_donaciones=total_donaciones,
                         productos_donados=productos_donados,
                         
                         # ML (funciones existentes)
                         tendencia=tendencia_ml,
                         alertas=alertas,
                         productos_analisis=productos_analisis,
                         productos_analisis_ml=productos_analisis_ml,
                         
                         # NUEVOS DATOS PARA GRÃFICOS Y ANÃLISIS
                         tendencia_ventas=tendencia_porcentaje,
                         ticket_promedio=promedio_venta,
                         
                         # Datos para grÃ¡ficos
                         top_productos_labels=top_productos_labels,
                         top_productos_data=top_productos_data,
                         categorias_labels=categorias_labels,
                         categorias_data=categorias_data,
                         tendencia_labels=tendencia_labels,
                         tendencia_data=tendencia_data,
                         porcentaje_ventas=porcentaje_ventas,
                         porcentaje_donaciones=porcentaje_donaciones,
                         
                         # Datos para secciones
                         ventas_detalle=ventas_periodo,
                         productos_vendidos=productos_vendidos,
                         recomendaciones=recomendaciones,
                         
                         datetime=datetime)
    

# Busca un lugar despuÃ©s de las otras rutas y agrega:

# ================================================== MÃ“DULO FINANCIERO ====================================================
# === NUEVO MÃ“DULO FINANCIERO INTUITIVO ===

# === FUNCIONES AUXILIARES ===
# ================================================== MÃ“DULO FINANCIERO ====================================================

# === FUNCIONES AUXILIARES MEJORADAS ===
def obtener_ventas_del_dia(fecha):
    """Obtener ventas reales del punto de venta para una fecha especÃ­fica"""
    try:
        from datetime import datetime, timedelta
        # Convertir fecha para comparaciÃ³n
        fecha_inicio = datetime(fecha.year, fecha.month, fecha.day)
        fecha_fin = fecha_inicio + timedelta(days=1)
        
        # Buscar ventas en ese rango de fechas
        ventas = Venta.query.filter(
            Venta.fecha_hora >= fecha_inicio,
            Venta.fecha_hora < fecha_fin
        ).all()
        
        total_ventas = sum(venta.total for venta in ventas)
        return total_ventas
        
    except Exception as e:
        print(f"Error al obtener ventas: {e}")
        return 0

def actualizar_saldo_automatico(efectivo=0, transferencias=0, pagos=0, accion_efectivo="depositar"):
    """
    Actualizar saldo automÃ¡ticamente considerando ingresos y egresos
    - transferencias: dinero que ENTRA a la cuenta
    - pagos: dinero que SALE de la cuenta
    - efectivo: depende de la acciÃ³n seleccionada
    """
    try:
        saldo_actual_obj = SaldoBanco.query.order_by(SaldoBanco.fecha_actualizacion.desc()).first()
        saldo_actual = saldo_actual_obj.saldo_actual if saldo_actual_obj else 0
        
        # Calcular nuevo saldo
        nuevo_saldo = saldo_actual
        
        # SUMAR: Transferencias (siempre entran a la cuenta)
        nuevo_saldo += (transferencias or 0)
        
        # SUMAR: Efectivo solo si se deposita
        if accion_efectivo == "depositar":
            nuevo_saldo += (efectivo or 0)
        
        # RESTAR: Pagos realizados (dinero que sale de la cuenta)
        nuevo_saldo -= (pagos or 0)
        
        # Generar comentario descriptivo
        comentario = f"ActualizaciÃ³n: "
        partes = []
        if transferencias > 0:
            partes.append(f"+${transferencias:,.0f} transferencias")
        if efectivo > 0 and accion_efectivo == "depositar":
            partes.append(f"+${efectivo:,.0f} efectivo depositado")
        if pagos > 0:
            partes.append(f"-${pagos:,.0f} pagos")
        
        comentario += " | ".join(partes) if partes else "Sin movimientos"
        
        # Crear nuevo registro de saldo
        nuevo_registro_saldo = SaldoBanco(panaderia_id=1, 
            saldo_actual=nuevo_saldo,
            comentario=comentario
        )
        
        db.session.add(nuevo_registro_saldo)
        return nuevo_saldo
        
    except Exception as e:
        print(f"Error al actualizar saldo: {e}")
        return saldo_actual

def sanitizar_numero(valor, default=0.0):
    """Convierte valores a float de forma segura, manejando None y strings vacÃ­os"""
    try:
        if valor is None or valor == '':
            return default
        return float(valor)
    except (ValueError, TypeError):
        return default

# === RUTAS MEJORADAS ===

@app.route('/registrar_dia', methods=['POST'])
@login_required
@modulo_requerido('finanzas')
def registrar_dia():
    """Registrar los ingresos y gastos del dÃ­a"""
    try:
        from datetime import datetime
        
        # Obtener datos del formulario con sanitizaciÃ³n
        fecha = datetime.strptime(request.form['fecha'], '%Y-%m-%d').date()
        venta_total = sanitizar_numero(request.form.get('venta_total'))
        
        # Ingresos con sanitizaciÃ³n
        efectivo = sanitizar_numero(request.form.get('efectivo'))
        transferencias = sanitizar_numero(request.form.get('transferencias'))
        tarjetas = sanitizar_numero(request.form.get('tarjetas'))
        
        # Gastos con sanitizaciÃ³n
        gasto_proveedores = sanitizar_numero(request.form.get('gasto_proveedores'))
        gasto_servicios = sanitizar_numero(request.form.get('gasto_servicios'))
        gasto_nomina = sanitizar_numero(request.form.get('gasto_nomina'))
        gasto_alquiler = sanitizar_numero(request.form.get('gasto_alquiler'))
        gasto_otros = sanitizar_numero(request.form.get('gasto_otros'))
        
        descripcion = request.form.get('descripcion', '')
        numero_factura = request.form.get('numero_factura', '')
        
        # Verificar si ya existe registro para esta fecha
        registro_existente = RegistroDiario.query.filter_by(panaderia_id=1, fecha=fecha).first()
        
        if registro_existente:
            # Actualizar registro existente
            registro = registro_existente
        else:
            # Crear nuevo registro
            registro = RegistroDiario(fecha=fecha, panaderia_id=1)
        
        # Actualizar datos
        registro.venta_total = venta_total
        registro.efectivo = efectivo
        registro.transferencias = transferencias
        registro.tarjetas = tarjetas
        registro.gasto_proveedores = gasto_proveedores
        registro.gasto_servicios = gasto_servicios
        registro.gasto_nomina = gasto_nomina
        registro.gasto_alquiler = gasto_alquiler
        registro.gasto_otros = gasto_otros
        registro.descripcion_gastos = descripcion
        registro.numero_factura = numero_factura
        
        # Calcular totales automÃ¡ticamente
        registro.calcular_totales()
        
        if not registro_existente:
            db.session.add(registro)
        
        db.session.commit()
        
        flash('âœ… Â¡DÃ­a registrado correctamente!', 'success')
        
    except Exception as e:
        flash(f'âŒ Error al registrar: {str(e)}', 'error')
    
    return redirect(url_for('control_diario'))

@app.route('/control_diario')
@login_required
@modulo_requerido('finanzas')
def control_diario():
    """Vista principal del control financiero diario"""
    from datetime import datetime, date
    
    # Obtener saldo actual
    saldo_banco = SaldoBanco.query.order_by(SaldoBanco.fecha_actualizacion.desc()).first()
    saldo_actual = saldo_banco.saldo_actual if saldo_banco else 0
    
    # Obtener registros recientes (Ãºltimos 7 dÃ­as)
    registros_recientes = RegistroDiario.query.filter_by(panaderia_id=1).order_by(RegistroDiario.fecha.desc()).limit(7).all()
    
    # Obtener proveedores para el dropdown
    proveedores = Proveedor.query.filter_by(panaderia_id=panaderia_actual).all()
    
    # Obtener pagos de hoy
    hoy = date.today()
    pagos_hoy = PagoIndividual.query.filter_by(panaderia_id=1, fecha_pago=hoy).all()
    registro_hoy = RegistroDiario.query.filter_by(panaderia_id=1, fecha=hoy).first()
    
    return render_template('control_diario.html',
                         saldo_actual=saldo_actual,
                         registros_recientes=registros_recientes,
                         registro_hoy=registro_hoy,
                         proveedores=proveedores,
                         pagos_hoy=pagos_hoy,
                         hoy=hoy)

@app.route('/registrar_pago_individual', methods=['POST'])
@login_required
@modulo_requerido('finanzas')
def registrar_pago_individual():
    """Registrar un pago individual con actualizaciÃ³n automÃ¡tica del saldo"""
    try:
        from datetime import datetime
        
        # Obtener datos del formulario con manejo de campos vacÃ­os
        categoria = request.form['categoria']
        monto = sanitizar_numero(request.form.get('monto'), 0.0)
        
        # Validar que el monto sea positivo
        if monto <= 0:
            flash('âŒ El monto debe ser mayor a 0', 'error')
            return redirect(url_for('control_diario'))
        
        fecha_pago = datetime.strptime(request.form['fecha_pago'], '%Y-%m-%d').date()
        referencia = request.form.get('referencia', '')
        descripcion = request.form.get('descripcion', '')
        numero_factura = request.form.get('numero_factura', '')
        
        # Proveedor (solo para categorÃ­a de materias primas)
        proveedor_id = None
        if categoria == 'MATERIAS_PRIMAS':
            proveedor_id_str = request.form.get('proveedor_id', '')
            if proveedor_id_str and proveedor_id_str.strip():
                try:
                    proveedor_id = int(proveedor_id_str)
                except ValueError:
                    proveedor_id = None
        
        # Crear nuevo pago
        nuevo_pago = PagoIndividual(panaderia_id=1, 
            categoria=categoria,
            proveedor_id=proveedor_id,
            monto=monto,
            fecha_pago=fecha_pago,
            referencia=referencia,
            descripcion=descripcion,
            numero_factura=numero_factura
        )
        
        db.session.add(nuevo_pago)
        
        # ðŸ†• ACTUALIZAR SALDO - RESTAR EL PAGO
        saldo_actual = actualizar_saldo_automatico(
            efectivo=0,
            transferencias=0, 
            pagos=monto,  # Restar el monto del pago
            accion_efectivo="depositar"  # No relevante para pagos
        )
        
        db.session.commit()
        
        flash(f'âœ… Pago registrado: ${monto:,.0f} - {categoria} - Saldo actual: ${saldo_actual:,.0f}', 'success')
        
    except ValueError as e:
        flash(f'âŒ Error en los datos numÃ©ricos: {str(e)}', 'error')
    except Exception as e:
        flash(f'âŒ Error al registrar pago: {str(e)}', 'error')
    
    return redirect(url_for('control_diario'))

@app.route('/registrar_cierre_caja', methods=['POST'])
@login_required
@modulo_requerido('finanzas')
def registrar_cierre_caja():
    """Registrar el cierre de caja diario con validaciones de seguridad"""
    try:
        from datetime import datetime
        
        # Obtener datos del formulario con sanitizaciÃ³n
        fecha = datetime.strptime(request.form['fecha'], '%Y-%m-%d').date()
        venta_total = sanitizar_numero(request.form.get('venta_total', 0))
        efectivo = sanitizar_numero(request.form.get('efectivo', 0))
        transferencias = sanitizar_numero(request.form.get('transferencias', 0))
        tarjetas = sanitizar_numero(request.form.get('tarjetas', 0))
        accion_efectivo = request.form.get('accion_efectivo', 'depositar')
        
        # ðŸ”’ VALIDACIÃ“N CRÃTICA: Verificar que la suma coincida con el total
        suma_metodos = efectivo + transferencias + tarjetas
        diferencia = abs(suma_metodos - venta_total)
        
        if diferencia > 1:
            if suma_metodos > venta_total:
                flash(f'âŒ El total ingresado en mÃ©todos de pago (${suma_metodos:,.0f}) es SUPERIOR al total de ventas (${venta_total:,.0f}). Diferencia: +${diferencia:,.0f}', 'error')
            else:
                flash(f'âŒ El total ingresado en mÃ©todos de pago (${suma_metodos:,.0f}) es INFERIOR al total de ventas (${venta_total:,.0f}). Diferencia: -${diferencia:,.0f}', 'error')
            return redirect(url_for('control_diario'))
        
        # Verificar si ya existe registro para esta fecha
        registro_existente = RegistroDiario.query.filter_by(panaderia_id=1, fecha=fecha).first()
        
        if registro_existente:
            registro = registro_existente
        else:
            registro = RegistroDiario(fecha=fecha, panaderia_id=1)
        
        # Actualizar datos de ingresos
        registro.venta_total = venta_total
        registro.efectivo = efectivo
        registro.transferencias = transferencias
        registro.tarjetas = tarjetas
        
        # Calcular totales automÃ¡ticamente
        registro.calcular_totales()
        
        if not registro_existente:
            db.session.add(registro)
        
        # ðŸ†• ACTUALIZAR SALDO - SOLO INGRESOS (no pagos aquÃ­)
        saldo_actual = actualizar_saldo_automatico(
            efectivo=efectivo, 
            transferencias=transferencias, 
            pagos=0,  # Los pagos se actualizan en su propia ruta
            accion_efectivo=accion_efectivo
        )
        
        db.session.commit()
        
        # Mensaje personalizado
        if accion_efectivo == "depositar":
            flash(f'âœ… Cierre de caja registrado! Ingresos: ${venta_total:,.0f} - Saldo actualizado: ${saldo_actual:,.0f}', 'success')
        else:
            flash(f'âœ… Cierre de caja registrado! Ingresos: ${venta_total:,.0f} - Saldo actualizado: ${saldo_actual:,.0f} (Efectivo en caja)', 'success')
        
    except Exception as e:
        flash(f'âŒ Error al registrar cierre: {str(e)}', 'error')
    
    return redirect(url_for('control_diario'))

# ... todo tu cÃ³digo existente ...

# ================================================== MÃ“DULO DE REPORTES ====================================================

from reportes import GeneradorReportes
from io import BytesIO

@app.route('/reportes')
@login_required
@modulo_requerido('reportes')
def reportes():
    """Vista principal de reportes"""
    return render_template('reportes.html')

@app.route('/generar_reporte_estado_resultados')
@login_required
@modulo_requerido('reportes')
def generar_reporte_estado_resultados():
    """Genera reporte de Estado de Resultados en PDF"""
    try:
        from datetime import datetime
        
        fecha_inicio = request.args.get('fecha_inicio')
        fecha_fin = request.args.get('fecha_fin')
        
        # Validar fechas
        if not fecha_inicio or not fecha_fin:
            flash('âŒ Debes seleccionar ambas fechas', 'error')
            return redirect(url_for('reportes'))
        
        fecha_inicio = datetime.strptime(fecha_inicio, '%Y-%m-%d').date()
        fecha_fin = datetime.strptime(fecha_fin, '%Y-%m-%d').date()
        
        if fecha_inicio > fecha_fin:
            flash('âŒ La fecha de inicio no puede ser mayor a la fecha fin', 'error')
            return redirect(url_for('reportes'))
        
        generador = GeneradorReportes()
        pdf_buffer = generador.generar_reporte_estado_resultados(fecha_inicio, fecha_fin)
        
        nombre_archivo = f"estado_resultados_{fecha_inicio}_{fecha_fin}.pdf"
        
        return Response(
            pdf_buffer,
            mimetype='application/pdf',
            headers={
                'Content-Disposition': f'attachment; filename={nombre_archivo}'
            }
        )
        
    except Exception as e:
        flash(f'âŒ Error al generar reporte: {str(e)}', 'error')
        return redirect(url_for('reportes'))

@app.route('/generar_reporte_flujo_caja')
@login_required
@modulo_requerido('reportes')
def generar_reporte_flujo_caja():
    """Genera reporte de Flujo de Caja en PDF"""
    try:
        from datetime import datetime
        
        fecha_inicio = request.args.get('fecha_inicio')
        fecha_fin = request.args.get('fecha_fin')
        
        # Validar fechas
        if not fecha_inicio or not fecha_fin:
            flash('âŒ Debes seleccionar ambas fechas', 'error')
            return redirect(url_for('reportes'))
        
        fecha_inicio = datetime.strptime(fecha_inicio, '%Y-%m-%d').date()
        fecha_fin = datetime.strptime(fecha_fin, '%Y-%m-%d').date()
        
        if fecha_inicio > fecha_fin:
            flash('âŒ La fecha de inicio no puede ser mayor a la fecha fin', 'error')
            return redirect(url_for('reportes'))
        
        generador = GeneradorReportes()
        pdf_buffer = generador.generar_reporte_flujo_caja(fecha_inicio, fecha_fin)
        
        nombre_archivo = f"flujo_caja_{fecha_inicio}_{fecha_fin}.pdf"
        
        return Response(
            pdf_buffer,
            mimetype='application/pdf',
            headers={
                'Content-Disposition': f'attachment; filename={nombre_archivo}'
            }
        )
        
    except Exception as e:
        flash(f'âŒ Error al generar reporte: {str(e)}', 'error')
        return redirect(url_for('reportes'))
    
#===============================================libro contable==========================================================

@app.route('/generar_reporte_libro_diario')
@login_required
@modulo_requerido('reportes')
def generar_reporte_libro_diario():
    """Genera reporte de Libro Diario Contable en PDF"""
    try:
        from datetime import datetime
        
        fecha_inicio = request.args.get('fecha_inicio')
        fecha_fin = request.args.get('fecha_fin')
        
        # Validar fechas
        if not fecha_inicio or not fecha_fin:
            flash('âŒ Debes seleccionar ambas fechas', 'error')
            return redirect(url_for('reportes'))
        
        fecha_inicio = datetime.strptime(fecha_inicio, '%Y-%m-%d').date()
        fecha_fin = datetime.strptime(fecha_fin, '%Y-%m-%d').date()
        
        if fecha_inicio > fecha_fin:
            flash('âŒ La fecha de inicio no puede ser mayor a la fecha fin', 'error')
            return redirect(url_for('reportes'))
        
        generador = GeneradorReportes()
        pdf_buffer = generador.generar_reporte_libro_diario(fecha_inicio, fecha_fin)
        
        nombre_archivo = f"libro_diario_{fecha_inicio}_{fecha_fin}.pdf"
        
        return Response(
            pdf_buffer,
            mimetype='application/pdf',
            headers={
                'Content-Disposition': f'attachment; filename={nombre_archivo}'
            }
        )
        
    except Exception as e:
        flash(f'âŒ Error al generar reporte: {str(e)}', 'error')
        return redirect(url_for('reportes'))
#===========================================Conciliacion Babcaria===================================================
@app.route('/generar_reporte_conciliacion')
@login_required
@modulo_requerido('reportes')
def generar_reporte_conciliacion():
    """Genera reporte de ConciliaciÃ³n Bancaria en PDF"""
    try:
        fecha_corte = request.args.get('fecha_corte')
        saldo_extracto_str = request.args.get('saldo_extracto', '0')
        
        # Validar fecha
        if not fecha_corte:
            flash('âŒ Debes seleccionar la fecha de corte', 'error')
            return redirect(url_for('reportes'))
        
        fecha_corte = datetime.strptime(fecha_corte, '%Y-%m-%d').date()
        saldo_extracto = float(saldo_extracto_str) if saldo_extracto_str else 0
        
        print(f"ðŸ” Generando conciliaciÃ³n para fecha: {fecha_corte}, saldo: {saldo_extracto}")
        
        generador = GeneradorReportes()
        pdf_buffer = generador.generar_reporte_conciliacion_bancaria(fecha_corte, saldo_extracto)
        
        # Verificar que el buffer no estÃ© vacÃ­o
        buffer_size = pdf_buffer.getbuffer().nbytes
        print(f"ðŸ“Š TamaÃ±o del buffer PDF: {buffer_size} bytes")
        
        if buffer_size == 0:
            raise Exception("El PDF generado estÃ¡ vacÃ­o")
        
        nombre_archivo = f"conciliacion_bancaria_{fecha_corte}.pdf"
        
        # Obtener los datos del buffer
        pdf_data = pdf_buffer.getvalue()
        
        return Response(
            pdf_data,
            mimetype='application/pdf',
            headers={
                'Content-Disposition': f'attachment; filename={nombre_archivo}'
            }
        )
        
    except Exception as e:
        print(f"âŒ Error detallado en generaciÃ³n de conciliaciÃ³n: {str(e)}")
        import traceback
        traceback.print_exc()
        flash(f'âŒ Error al generar conciliaciÃ³n: {str(e)}', 'error')
        return redirect(url_for('reportes'))
    
#========================================== AnÃ¡lisis de Gastos por CategorÃ­a=================================================
# DEBUG: Verificar mÃ©todos disponibles

generador_test = GeneradorReportes()
metodos = [method for method in dir(generador_test) if callable(getattr(generador_test, method)) and not method.startswith('_')]


@app.route('/generar_reporte_analisis_gastos')
@login_required
@modulo_requerido('reportes')
def generar_reporte_analisis_gastos():
    """Genera reporte de AnÃ¡lisis de Gastos por CategorÃ­a en PDF"""
    try:
        fecha_inicio = request.args.get('fecha_inicio')
        fecha_fin = request.args.get('fecha_fin')
        
        # Validar fechas
        if not fecha_inicio or not fecha_fin:
            flash('âŒ Debes seleccionar ambas fechas', 'error')
            return redirect(url_for('reportes'))
        
        fecha_inicio = datetime.strptime(fecha_inicio, '%Y-%m-%d').date()
        fecha_fin = datetime.strptime(fecha_fin, '%Y-%m-%d').date()
        
        if fecha_inicio > fecha_fin:
            flash('âŒ La fecha de inicio no puede ser mayor a la fecha fin', 'error')
            return redirect(url_for('reportes'))
        
        generador = GeneradorReportes()
        pdf_buffer = generador.generar_reporte_analisis_gastos(fecha_inicio, fecha_fin)
        
        # Verificar que el buffer no estÃ© vacÃ­o
        if pdf_buffer.getbuffer().nbytes == 0:
            raise Exception("El PDF generado estÃ¡ vacÃ­o")
        
        nombre_archivo = f"analisis_gastos_{fecha_inicio}_a_{fecha_fin}.pdf"
        
        return Response(
            pdf_buffer.getvalue(),
            mimetype='application/pdf',
            headers={
                'Content-Disposition': f'attachment; filename={nombre_archivo}'
            }
        )
        
    except Exception as e:
        print(f"Error al generar anÃ¡lisis de gastos: {str(e)}")
        import traceback
        traceback.print_exc()
        flash(f'âŒ Error al generar anÃ¡lisis de gastos: {str(e)}', 'error')
        return redirect(url_for('reportes'))

# VerificaciÃ³n temporal de mÃ©todos
def verificar_metodos():
    generador = GeneradorReportes()
    metodos = [method for method in dir(generador) if callable(getattr(generador, method)) and not method.startswith('_')]
    

# Ejecutar verificaciÃ³n (esto se mostrarÃ¡ en la terminal de Flask al iniciar)
verificar_metodos()

#==========================================================Tendencia de Ventas==============================================

@app.route('/generar_reporte_tendencia_ventas')
@login_required
@modulo_requerido('reportes')
def generar_reporte_tendencia_ventas():
    """Genera reporte de Tendencia de Ventas en PDF"""
    try:
        fecha_inicio = request.args.get('fecha_inicio')
        fecha_fin = request.args.get('fecha_fin')
        
        # Validar fechas
        if not fecha_inicio or not fecha_fin:
            flash('âŒ Debes seleccionar ambas fechas', 'error')
            return redirect(url_for('reportes'))
        
        fecha_inicio = datetime.strptime(fecha_inicio, '%Y-%m-%d').date()
        fecha_fin = datetime.strptime(fecha_fin, '%Y-%m-%d').date()
        
        if fecha_inicio > fecha_fin:
            flash('âŒ La fecha de inicio no puede ser mayor a la fecha fin', 'error')
            return redirect(url_for('reportes'))
        
        generador = GeneradorReportes()
        pdf_buffer = generador.generar_reporte_tendencia_ventas(fecha_inicio, fecha_fin)
        
        nombre_archivo = f"tendencia_ventas_{fecha_inicio}_a_{fecha_fin}.pdf"
        
        return Response(
            pdf_buffer.getvalue(),
            mimetype='application/pdf',
            headers={
                'Content-Disposition': f'attachment; filename={nombre_archivo}'
            }
        )
        
    except Exception as e:
        print(f"Error al generar tendencia de ventas: {str(e)}")
        flash(f'âŒ Error al generar tendencia de ventas: {str(e)}', 'error')
        return redirect(url_for('reportes'))
    
# ===============================================Recomendaciones con IA===========================================================
    
    # ========================================================== IA Predictivo ===============================================

@app.route('/generar_reporte_ia_predictivo')
@login_required
@modulo_requerido('reportes')
def generar_reporte_ia_predictivo():
    """Genera reporte de IA Predictivo en PDF"""
    try:
        fecha_inicio = request.args.get('fecha_inicio')
        fecha_fin = request.args.get('fecha_fin')
        
        # Validar fechas
        if not fecha_inicio or not fecha_fin:
            flash('âŒ Debes seleccionar ambas fechas', 'error')
            return redirect(url_for('reportes'))
        
        fecha_inicio = datetime.strptime(fecha_inicio, '%Y-%m-%d').date()
        fecha_fin = datetime.strptime(fecha_fin, '%Y-%m-%d').date()
        
        if fecha_inicio > fecha_fin:
            flash('âŒ La fecha de inicio no puede ser mayor a la fecha fin', 'error')
            return redirect(url_for('reportes'))
        
        generador = GeneradorReportes()
        pdf_buffer = generador.generar_reporte_ia_predictivo(fecha_inicio, fecha_fin)
        
        nombre_archivo = f"analisis_ia_predictivo_{fecha_inicio}_a_{fecha_fin}.pdf"
        
        return Response(
            pdf_buffer.getvalue(),
            mimetype='application/pdf',
            headers={
                'Content-Disposition': f'attachment; filename={nombre_archivo}'
            }
        )
        
    except Exception as e:
        print(f"Error al generar reporte de IA: {str(e)}")
        flash(f'âŒ Error al generar anÃ¡lisis de IA: {str(e)}', 'error')
        return redirect(url_for('reportes'))
    

#========================================= AnÃ¡lisis de Inventarios=============================================================

# ========================================================== AnÃ¡lisis de Inventarios ===============================================

@app.route('/generar_reporte_analisis_inventarios')
@login_required
@modulo_requerido('reportes')
def generar_reporte_analisis_inventarios():
    """Genera reporte de AnÃ¡lisis de Inventarios en PDF"""
    try:
        fecha_inicio = request.args.get('fecha_inicio')
        fecha_fin = request.args.get('fecha_fin')
        
        # Validar fechas
        if not fecha_inicio or not fecha_fin:
            flash('âŒ Debes seleccionar ambas fechas', 'error')
            return redirect(url_for('reportes'))
        
        fecha_inicio = datetime.strptime(fecha_inicio, '%Y-%m-%d').date()
        fecha_fin = datetime.strptime(fecha_fin, '%Y-%m-%d').date()
        
        if fecha_inicio > fecha_fin:
            flash('âŒ La fecha de inicio no puede ser mayor a la fecha fin', 'error')
            return redirect(url_for('reportes'))
        
        generador = GeneradorReportes()
        pdf_buffer = generador.generar_reporte_analisis_inventarios(fecha_inicio, fecha_fin)
        
        nombre_archivo = f"analisis_inventarios_{fecha_inicio}_a_{fecha_fin}.pdf"
        
        return Response(
            pdf_buffer.getvalue(),
            mimetype='application/pdf',
            headers={
                'Content-Disposition': f'attachment; filename={nombre_archivo}'
            }
        )
        
    except Exception as e:
        print(f"Error al generar anÃ¡lisis de inventarios: {str(e)}")
        flash(f'âŒ Error al generar anÃ¡lisis de inventarios: {str(e)}', 'error')
        return redirect(url_for('reportes'))
    
# ============================================ MODELO DE ACTIVOS FIJOS ========================================================

# === RUTAS DE ACTIVOS FIJOS ===

@app.route('/activos_fijos')
@login_required
@modulo_requerido('activos')
def activos_fijos():
    activos = ActivoFijo.query.filter_by(panaderia_id=1).all()
    
    # Calcular mÃ©tricas
    total_activos = len(activos)
    valor_total = sum(activo.valor_actual() for activo in activos)
    activos_mantenimiento = len([a for a in activos if a.estado == 'MANTENIMIENTO'])
    
    return render_template('activos_fijos.html', 
                         activos=activos,
                         total_activos=total_activos,
                         valor_total=valor_total,
                         activos_mantenimiento=activos_mantenimiento,
                         proxima_depreciacion=0,
                         categorias=CATEGORIAS_ACTIVOS)

@app.route('/registrar_activo', methods=['GET', 'POST'])
@login_required
@modulo_requerido('activos')
def registrar_activo():
    if request.method == 'POST':
        try:
            # Obtener datos del formulario
            nombre = request.form['nombre']
            categoria = request.form['categoria']
            descripcion = request.form['descripcion']
            numero_serie = request.form['numero_serie']
            fecha_compra = datetime.strptime(request.form['fecha_compra'], '%Y-%m-%d').date()
            proveedor = request.form['proveedor']
            valor_compra = float(request.form['valor_compra'])
            metodo_pago = request.form['metodo_pago']
            vida_util = int(request.form['vida_util'])
            valor_residual = float(request.form.get('valor_residual', 0))
            ubicacion = request.form['ubicacion']
            responsable = request.form['responsable']
            
            # Crear nuevo activo
            nuevo_activo = ActivoFijo(panaderia_id=1, 
                nombre=nombre,
                categoria=categoria,
                descripcion=descripcion,
                numero_serie=numero_serie,
                fecha_compra=fecha_compra,
                proveedor=proveedor,
                valor_compra=valor_compra,
                metodo_pago=metodo_pago,
                vida_util=vida_util,
                valor_residual=valor_residual,
                ubicacion=ubicacion,
                responsable=responsable,
                estado='ACTIVO'
            )
            
            db.session.add(nuevo_activo)
            db.session.commit()
            
            flash('Activo registrado exitosamente', 'success')
            return redirect(url_for('activos_fijos'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Error al registrar activo: {str(e)}', 'error')
    
    return render_template('registrar_activo.html', categorias=CATEGORIAS_ACTIVOS)

@app.route('/lista_activos')
@login_required
@modulo_requerido('activos')
def lista_activos():
    activos = ActivoFijo.query.order_by(ActivoFijo.fecha_compra.desc()).all()
    return render_template('lista_activos.html', activos=activos, categorias=CATEGORIAS_ACTIVOS)

@app.route('/reporte_activos')
@login_required
@modulo_requerido('activos')
def reporte_activos():
    activos = ActivoFijo.query.filter_by(panaderia_id=1).all()
    
    # Generar grÃ¡ficos si hay activos
    if activos:
        try:
            fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(12, 10))
            
            # GrÃ¡fico 1: DistribuciÃ³n por categorÃ­a
            categorias_count = {}
            for activo in activos:
                cat_nombre = CATEGORIAS_ACTIVOS.get(activo.categoria, activo.categoria)
                categorias_count[cat_nombre] = categorias_count.get(cat_nombre, 0) + 1
            
            if categorias_count:
                ax1.pie(categorias_count.values(), labels=categorias_count.keys(), autopct='%1.1f%%')
                ax1.set_title('DistribuciÃ³n de Activos por CategorÃ­a')
            
            # GrÃ¡fico 2: Valor por categorÃ­a
            categorias_valor = {}
            for activo in activos:
                cat_nombre = CATEGORIAS_ACTIVOS.get(activo.categoria, activo.categoria)
                categorias_valor[cat_nombre] = categorias_valor.get(cat_nombre, 0) + activo.valor_actual()
            
            if categorias_valor:
                ax2.bar(categorias_valor.keys(), categorias_valor.values())
                ax2.set_title('Valor Actual por CategorÃ­a')
                ax2.tick_params(axis='x', rotation=45)
            
            # GrÃ¡fico 3: Estado de activos
            estados_count = {}
            for activo in activos:
                estados_count[activo.estado] = estados_count.get(activo.estado, 0) + 1
            
            if estados_count:
                ax3.pie(estados_count.values(), labels=estados_count.keys(), autopct='%1.1f%%')
                ax3.set_title('Estado de los Activos')
            
            # GrÃ¡fico 4: DepreciaciÃ³n acumulada
            nombres = [activo.nombre[:15] + '...' if len(activo.nombre) > 15 else activo.nombre for activo in activos]
            valores_compra = [activo.valor_compra for activo in activos]
            depreciacion = [activo.depreciacion_acumulada() for activo in activos]
            
            x = range(len(activos))
            ax4.bar(x, valores_compra, label='Valor Compra', alpha=0.7)
            ax4.bar(x, depreciacion, label='DepreciaciÃ³n Acumulada', alpha=0.7)
            ax4.set_title('DepreciaciÃ³n Acumulada')
            ax4.legend()
            ax4.set_xticks(x)
            ax4.set_xticklabels(nombres, rotation=45, ha='right')
            
            plt.tight_layout()
            
            # Guardar grÃ¡fico
            graph_path = os.path.join('static', 'temp', 'activos_report.png')
            os.makedirs(os.path.dirname(graph_path), exist_ok=True)
            plt.savefig(graph_path)
            plt.close()
            
        except Exception as e:
            print(f"Error generando grÃ¡ficos: {e}")
            graph_path = None
    else:
        graph_path = None
    
    return render_template('reporte_activos.html', 
                         activos=activos, 
                         graph_path=graph_path,
                         total_valor=sum(activo.valor_actual() for activo in activos),
                         total_depreciacion=sum(activo.depreciacion_acumulada() for activo in activos),
                         now=datetime.now(),
                         categorias=CATEGORIAS_ACTIVOS)

@app.route('/api/activos_metrics')
@login_required
@modulo_requerido('activos')
def api_activos_metrics():
    activos = ActivoFijo.query.filter_by(panaderia_id=1).all()
    
    metrics = {
        'total_activos': len(activos),
        'valor_total': sum(activo.valor_actual() for activo in activos),
        'activos_mantenimiento': len([a for a in activos if a.estado == 'MANTENIMIENTO']),
        'proxima_depreciacion': 0
    }
    
    return jsonify(metrics)

#========================================= ðŸ†• RUTAS PARA GESTIÃ“N DE USUARIOS==================================================
@app.route('/gestion_usuarios')
@login_required
def gestion_usuarios():
    """GestiÃ³n de usuarios de la panaderÃ­a actual - SOLO para admin_cliente"""
    try:
        if 'user_id' not in session:
            return redirect(url_for('login'))
        
        # Solo admin_cliente puede gestionar usuarios de su panaderÃ­a
        if current_user.rol != 'admin_cliente':
            flash('No tienes permisos para gestionar usuarios', 'error')
            return redirect(url_for('dashboard'))
        
        panaderia_actual_id = obtener_panaderia_actual()
        
        # Obtener informaciÃ³n de la panaderÃ­a
        panaderia_actual = ConfiguracionPanaderia.query.get(panaderia_actual_id)
        
        if not panaderia_actual:
            flash('Error: No se encontrÃ³ informaciÃ³n de la panaderÃ­a', 'error')
            return redirect(url_for('dashboard'))
        
        # Obtener usuarios de ESTA panaderÃ­a
        usuarios = Usuario.query.filter_by(panaderia_id=panaderia_actual_id).all()
        
        # Debug en consola
        print(f"ðŸ” DEBUG GESTIÃ“N USUARIOS:")
        print(f"   PanaderÃ­a: {panaderia_actual.nombre_panaderia} (ID: {panaderia_actual_id})")
        print(f"   Usuarios: {len(usuarios)}")
        for usuario in usuarios:
            print(f"     - {usuario.username} ({usuario.rol})")
        
        return render_template('gestion_usuarios.html', 
                             usuarios=usuarios,
                             panaderia_actual=panaderia_actual)
                             
    except Exception as e:
        print(f"âŒ ERROR en gestiÃ³n_usuarios: {e}")
        flash('Error interno del servidor', 'error')
        return redirect(url_for('dashboard'))
    
    print(f"ðŸ” DEBUG GESTIÃ“N USUARIOS:")
    print(f"   PanaderÃ­a ID: {panaderia_actual_id}")
    print(f"   PanaderÃ­a Nombre: {panaderia_actual.nombre_panaderia}")
    print(f"   Usuarios encontrados: {len(usuarios)}")
    
    return render_template('gestion_usuarios.html', 
                         usuarios=usuarios,
                         panaderia_actual=panaderia_actual)

@app.route('/crear_usuario', methods=['GET', 'POST'])
@login_required
@permisos_requeridos('usuarios', 'gestionar')
def crear_usuario():
    """Crear nuevo usuario con verificaciÃ³n de lÃ­mites"""
    
    # ðŸ†• VERIFICAR LÃMITES ANTES DE CONTINUAR
    from models import obtener_limites_panaderia, verificar_limite_usuarios
    
    if verificar_limite_usuarios():
        limites = obtener_limites_panaderia()
        flash(f'âŒ LÃ­mite de usuarios alcanzado. Tienes {limites["usuarios_actuales"]}/{limites["max_usuarios"]} usuarios.', 'error')
        return redirect(url_for('gestion_usuarios'))
    
    if request.method == 'POST':
        try:
            username = request.form['username']
            password = request.form['password']
            nombre_completo = request.form['nombre_completo']
            email = request.form.get('email', '')
            telefono = request.form.get('telefono', '')
            rol = request.form['rol']
            
            # Verificar si usuario ya existe
            if Usuario.query.filter_by(username=username).first():
                flash('âŒ El nombre de usuario ya existe', 'error')
                return redirect(url_for('crear_usuario'))
            
            # ðŸ†• ASIGNAR PANADERÃA POR DEFECTO
            nuevo_usuario = Usuario(
                username=username,
                nombre_completo=nombre_completo,
                email=email,
                telefono=telefono,
                rol=rol,
                panaderia_id=1  # ðŸ†• ASIGNAR A PANADERÃA PRINCIPAL
            )
            nuevo_usuario.set_password(password)
            
            db.session.add(nuevo_usuario)
            db.session.commit()
            
            # ðŸ†• ACTUALIZAR INFORMACIÃ“N DE LÃMITES
            limites = obtener_limites_panaderia()
            
            flash(f'âœ… Usuario {username} creado exitosamente. ({limites["usuarios_restantes"]} usuarios restantes)', 'success')
            return redirect(url_for('gestion_usuarios'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'âŒ Error al crear usuario: {str(e)}', 'error')
    
    # ðŸ†• PASAR INFORMACIÃ“N DE LÃMITES AL TEMPLATE
    limites = obtener_limites_panaderia()
    return render_template('crear_usuario.html', limites=limites)

@app.route('/editar_usuario/<int:usuario_id>', methods=['GET', 'POST'])
@login_required
@permisos_requeridos('usuarios', 'gestionar')
def editar_usuario(usuario_id):
    """Editar usuario existente"""
    usuario = Usuario.query.get_or_404(usuario_id)
    
    if request.method == 'POST':
        try:
            usuario.nombre_completo = request.form['nombre_completo']
            usuario.email = request.form.get('email', '')
            usuario.telefono = request.form.get('telefono', '')
            usuario.rol = request.form['rol']
            usuario.activo = 'activo' in request.form
            
            # Si se proporcionÃ³ nueva contraseÃ±a
            nueva_password = request.form.get('nueva_password', '')
            if nueva_password:
                usuario.set_password(nueva_password)
            
            db.session.commit()
            flash(f'âœ… Usuario {usuario.username} actualizado', 'success')
            return redirect(url_for('gestion_usuarios'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'âŒ Error al actualizar usuario: {str(e)}', 'error')
    
    return render_template('editar_usuario.html', usuario=usuario)

@app.route('/toggle_usuario/<int:usuario_id>')
@login_required
@permisos_requeridos('usuarios', 'gestionar')
def toggle_usuario(usuario_id):
    """Activar/desactivar usuario"""
    if usuario_id == current_user.id:
        flash('âŒ No puedes desactivar tu propio usuario', 'error')
        return redirect(url_for('gestion_usuarios'))
    
    usuario = Usuario.query.get_or_404(usuario_id)
    usuario.activo = not usuario.activo
    
    estado = "activado" if usuario.activo else "desactivado"
    db.session.commit()
    
    flash(f'âœ… Usuario {usuario.username} {estado}', 'success')
    return redirect(url_for('gestion_usuarios'))

# ðŸ†• RUTA PARA PERFIL DE USUARIO
@app.route('/mi_perfil', methods=['GET', 'POST'])
@login_required
@modulo_requerido('usuarios')
def mi_perfil():
    """Perfil del usuario actual"""
    if request.method == 'POST':
        try:
            current_user.nombre_completo = request.form['nombre_completo']
            current_user.email = request.form.get('email', '')
            current_user.telefono = request.form.get('telefono', '')
            
            # Cambio de contraseÃ±a
            nueva_password = request.form.get('nueva_password', '')
            if nueva_password:
                current_user.set_password(nueva_password)
                flash('âœ… ContraseÃ±a actualizada correctamente', 'success')
            
            db.session.commit()
            flash('âœ… Perfil actualizado correctamente', 'success')
            return redirect(url_for('mi_perfil'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'âŒ Error al actualizar perfil: {str(e)}', 'error')
    
    return render_template('mi_perfil.html')

# ðŸ†• RUTAS PARA GESTIÃ“N DE PERMISOS - AGREGAR DESPUÃ‰S DE LAS RUTAS DE USUARIOS EXISTENTES

@app.route('/gestionar_permisos/<int:usuario_id>')
@login_required
def gestionar_permisos(usuario_id):
    """Interfaz para gestionar permisos de usuario"""
    # Solo administradores pueden gestionar permisos
    if not current_user.tiene_permiso('usuarios', 'gestionar'):
        flash('âŒ No tienes permisos para gestionar permisos', 'error')
        return redirect(url_for('dashboard'))
    
    usuario = Usuario.query.get_or_404(usuario_id)
    return render_template('gestionar_permisos.html', usuario=usuario)

@app.route('/guardar_permisos/<int:usuario_id>', methods=['POST'])
@login_required
def guardar_permisos(usuario_id):
    """Guardar permisos personalizados"""
    try:
        # Verificar permisos
        if not current_user.tiene_permiso('usuarios', 'gestionar'):
            flash('âŒ No tienes permisos para gestionar permisos', 'error')
            return redirect(url_for('dashboard'))
        
        usuario = Usuario.query.get_or_404(usuario_id)
        
        # Eliminar permisos existentes del usuario
        from models import PermisoUsuario
        PermisoUsuario.query.filter_by(usuario_id=usuario_id).delete()
        
        # Procesar nuevos permisos del formulario
        for key, value in request.form.items():
            if key.startswith('permiso_'):
                # Formato: permiso_modulo_accion
                partes = key.split('_')
                if len(partes) >= 3:
                    modulo = partes[1]
                    accion = partes[2]
                    
                    permiso = PermisoUsuario(
                        usuario_id=usuario_id,
                        modulo=modulo,
                        accion=accion,
                        permitido=True
                    )
                    db.session.add(permiso)
        
        db.session.commit()
        flash(f'âœ… Permisos de {usuario.username} actualizados correctamente', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'âŒ Error al guardar permisos: {str(e)}', 'error')
        print(f"Error guardando permisos: {e}")
    
    return redirect(url_for('gestion_usuarios'))

# =============================================
# ðŸ†• RUTAS PARA GESTIÃ“N DE CLIENTES (SUSCRIPCIONES)
# =============================================

@app.route('/gestion_clientes')
@login_required
@modulo_requerido('sistema')
def gestion_clientes():
    """Panel de gestiÃ³n de clientes/suscripciones"""
    from models import ConfiguracionPanaderia
    
    # Obtener todas las configuraciones (clientes)
    configuraciones = ConfiguracionPanaderia.query.all()
    
    # Calcular mÃ©tricas
    clientes_activos = sum(1 for c in configuraciones if c.suscripcion_activa)
    clientes_por_vencer = sum(1 for c in configuraciones if c.tipo_licencia != 'local' and 0 < c.dias_para_expiracion <= 7)
    clientes_vencidos = sum(1 for c in configuraciones if c.tipo_licencia != 'local' and not c.suscripcion_activa)
    total_clientes = len(configuraciones)
    
    return render_template('gestion_clientes.html',
                         configuraciones=configuraciones,
                         clientes_activos=clientes_activos,
                         clientes_por_vencer=clientes_por_vencer,
                         clientes_vencidos=clientes_vencidos,
                         total_clientes=total_clientes)

@app.route('/crear_cliente', methods=['POST'])
@login_required
@modulo_requerido('sistema')
def crear_cliente():
    """Crear un nuevo cliente/panaderÃ­a con usuarios automÃ¡ticos"""
    from models import ConfiguracionPanaderia, Usuario
    from werkzeug.security import generate_password_hash
    import secrets
    import string
    
    try:
        # Obtener datos del formulario
        nombre_panaderia = request.form.get('nombre_panaderia')
        telefono_contacto = request.form.get('telefono_contacto')
        direccion = request.form.get('direccion')
        tipo_licencia = request.form.get('tipo_licencia')
        max_usuarios = int(request.form.get('max_usuarios', 3))
        fecha_expiracion = request.form.get('fecha_expiracion')
        dias_gracia = int(request.form.get('dias_gracia', 7))
        razon_social = request.form.get('razon_social')
        nit = request.form.get('nit')
        
        # 1. Crear configuraciÃ³n de panaderÃ­a
        nueva_config = ConfiguracionPanaderia(
            nombre_panaderia=nombre_panaderia,
            telefono_contacto=telefono_contacto,
            direccion=direccion,
            tipo_licencia=tipo_licencia,
            max_usuarios=max_usuarios,
            dias_gracia=dias_gracia,
            razon_social=razon_social,
            nit=nit
        )
        
        # Solo agregar fecha de expiraciÃ³n para licencias en la nube
        if tipo_licencia != 'local' and fecha_expiracion:
            nueva_config.fecha_expiracion = datetime.strptime(fecha_expiracion, '%Y-%m-%d').date()
        
        db.session.add(nueva_config)
        db.session.flush()  # Para obtener el ID
        
        # 2. ðŸ†• CREAR USUARIOS AUTOMÃTICAMENTE
        panaderia_id = nueva_config.id
        
        # Generar contraseÃ±a temporal segura
        def generar_contrasena_temporal():
            caracteres = string.ascii_letters + string.digits + "!@#$%"
            return ''.join(secrets.choice(caracteres) for _ in range(10))
        
        contrasena_temp = generar_contrasena_temporal()
        
        # Usuarios a crear
        usuarios_base = [
            {
                'username': f'admin_{panaderia_id}',
                'rol': 'admin_cliente',
                'nombre': f'Administrador {nombre_panaderia}'
            },
            {
                'username': f'super_{panaderia_id}',
                'rol': 'supervisor', 
                'nombre': f'Supervisor {nombre_panaderia}'
            },
            {
                'username': f'cajero_{panaderia_id}',
                'rol': 'cajero',
                'nombre': f'Cajero Principal {nombre_panaderia}'
            }
        ]
        
        usuarios_creados = []
        
        for user_data in usuarios_base:
            usuario = Usuario(
                username=user_data['username'],
                password_hash=generate_password_hash(contrasena_temp),
                nombre_completo=user_data['nombre'],
                rol=user_data['rol'],
                panaderia_id=panaderia_id
            )
            db.session.add(usuario)
            usuarios_creados.append(user_data['username'])
        
        db.session.commit()
        
        # ðŸ†• =============================================
        # ðŸ†• CREAR TENANT SAAS AUTOMÃTICAMENTE
        # ðŸ†• =============================================
        try:
            # Generar subdominio Ãºnico desde el nombre de la panaderÃ­a
            subdominio = nombre_panaderia.lower().replace(' ', '_').replace('-', '_')[:20]
            subdominio = ''.join(c for c in subdominio if c.isalnum() or c == '_')
            
            # Email de contacto para el admin del tenant
            email_admin = f"admin_{subdominio}@panaderias.com"
            
            # Crear tenant SaaS
            exito, mensaje, tenant_id = crear_tenant_saas(nombre_panaderia, subdominio, email_admin)
            
            if exito:
                print(f"âœ… SaaS: {mensaje}")
                # AÃ±adir mensaje SaaS al flash existente
                flash(
                    f'âœ… Cliente "{nombre_panaderia}" creado exitosamente | '
                    f'ðŸ‘¥ Usuarios: {", ".join(usuarios_creados)} | '
                    f'ðŸ”‘ ContraseÃ±a: {contrasena_temp} | '
                    f'ðŸª Tenant SaaS: {subdominio} | '
                    f'ðŸ’¡ Cambiar contraseÃ±a al primer inicio',
                    'success'
                )
            else:
                print(f"âš ï¸  SaaS: {mensaje}")
                # Mantener mensaje original + advertencia SaaS
                flash(
                    f'âœ… Cliente "{nombre_panaderia}" creado exitosamente | '
                    f'ðŸ‘¥ Usuarios: {", ".join(usuarios_creados)} | '
                    f'ðŸ”‘ ContraseÃ±a: {contrasena_temp} | '
                    f'âš ï¸ SaaS: {mensaje} | '
                    f'ðŸ’¡ Cambiar contraseÃ±a al primer inicio',
                    'warning'
                )
                
        except Exception as e:
            print(f"âš ï¸  Error creando tenant SaaS: {e}")
            # Mantener mensaje original + error SaaS
            flash(
                f'âœ… Cliente "{nombre_panaderia}" creado exitosamente | '
                f'ðŸ‘¥ Usuarios: {", ".join(usuarios_creados)} | '
                f'ðŸ”‘ ContraseÃ±a: {contrasena_temp} | '
                f'âš ï¸ Error SaaS: {str(e)} | '
                f'ðŸ’¡ Cambiar contraseÃ±a al primer inicio',
                'warning'
            )
        # ðŸ†• FIN INTEGRACIÃ“N SAAS
        # ðŸ†• =============================================
        
    except Exception as e:
        db.session.rollback()
        flash(f'âŒ Error al crear cliente: {str(e)}', 'error')
    
    return redirect(url_for('gestion_clientes'))

@app.route('/resetear_password/<int:usuario_id>', methods=['POST'])
@login_required
def resetear_password(usuario_id):
    """ðŸŽ¯ SISTEMA DE RESETEO PROFESIONAL - PREPARADO PARA MIGRACIÃ“N"""
    if current_user.rol != 'super_admin':
        return jsonify({
            'success': False, 
            'error': 'âŒ Solo super_admin puede resetear contraseÃ±as'
        })
    
    try:
        usuario = Usuario.query.get_or_404(usuario_id)
        
        # ðŸŽ¯ GENERACIÃ“N DE CONTRASEÃ‘A SEGURA (MEJORES PRÃCTICAS)
        nueva_password = generar_contrasena_segura()
        
        # ðŸŽ¯ ESTRATEGIA HÃBRIDA TEMPORAL - COMPATIBILIDAD CON SISTEMA ACTUAL
        # Durante transiciÃ³n, usar hash simple para garantizar funcionamiento
        # En FASE 2, migraremos gradualmente a hash seguro
        usuario.password_hash = f"dev_{nueva_password}_hash"
        
        # ðŸ” REGISTRO DE ACTIVIDAD (PREPARACIÃ“N PARA AUDITORÃA)
        registrar_reseteo_password(usuario.id, current_user.id)
        
        db.session.commit()
        
        # ðŸŽ¯ RESPUESTA PROFESIONAL CON INFORMACIÃ“N COMPLETA
        return jsonify({
            'success': True,
            'nueva_password': nueva_password,
            'usuario': usuario.username,
            'panaderia_id': usuario.panaderia_id,
            'nota': 'ðŸ”’ En producciÃ³n, esta contraseÃ±a se enviarÃ¡ automÃ¡ticamente por email',
            'instrucciones': [
                '1. Compartir esta contraseÃ±a de manera segura con el usuario',
                '2. El usuario debe cambiar la contraseÃ±a en su primer acceso',
                '3. En FASE 2, esto serÃ¡ automÃ¡tico por email'
            ]
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"âŒ [RESETEO] Error: {e}")
        return jsonify({
            'success': False, 
            'error': f'Error al resetear contraseÃ±a: {str(e)}'
        })

def generar_contrasena_segura():
    """
    ðŸŽ¯ GENERADOR PROFESIONAL DE CONTRASEÃ‘AS - MEJORES PRÃCTICAS DE SEGURIDAD
    """
    import secrets
    import string
    
    # ðŸŽ¯ CONFIGURACIÃ“N DE SEGURIDAD
    longitud = 12  # Longitud Ã³ptima para seguridad y usabilidad
    caracteres = string.ascii_letters + string.digits + "!@#$%"
    
    # ðŸŽ¯ GARANTIZAR COMPLEJIDAD MÃNIMA (AL MENOS UNO DE CADA TIPO)
    intentos_maximos = 10  # Prevenir bucles infinitos
    
    for intento in range(intentos_maximos):
        password = ''.join(secrets.choice(caracteres) for _ in range(longitud))
        
        # VERIFICAR CRITERIOS DE COMPLEJIDAD
        tiene_minuscula = any(c.islower() for c in password)
        tiene_mayuscula = any(c.isupper() for c in password)
        tiene_numero = any(c.isdigit() for c in password)
        tiene_simbolo = any(c in "!@#$%" for c in password)
        
        if todas([tiene_minuscula, tiene_mayuscula, tiene_numero, tiene_simbolo]):
            print(f"âœ… [GENERADOR] ContraseÃ±a segura generada en intento {intento + 1}")
            return password
    
    # ðŸŽ¯ FALLBACK: Si no cumple criterios despuÃ©s de intentos, generar una igual
    password_fallback = ''.join(secrets.choice(caracteres) for _ in range(longitud))
    print(f"âš ï¸ [GENERADOR] Usando fallback despuÃ©s de {intentos_maximos} intentos")
    return password_fallback

def todas(condiciones):
    """ðŸŽ¯ FUNCIÃ“N AUXILIAR PARA VERIFICAR MÃšLTIPLES CONDICIONES"""
    return all(condiciones)

def registrar_reseteo_password(usuario_id, administrador_id):
    """
    ðŸŽ¯ PREPARACIÃ“N PARA AUDITORÃA DE SEGURIDAD PROFESIONAL
    En FASE 2, esto se migrarÃ¡ a tabla de auditorÃ­a en base de datos
    """
    try:
        # ðŸ“Š LOG TEMPORAL - EN FASE 2 SE MIGRA A BASE DE DATOS
        print(f"ðŸ“Š [AUDITORÃA] Reseteo - Usuario: {usuario_id}, Admin: {administrador_id}")
        
        # ðŸ†• CÃ“DIGO PREPARADO PARA FASE 2 (ACTUALMENTE COMENTADO)
        # from datetime import datetime
        # from models import AuditoriaSeguridad  # ðŸŽ¯ TABLA POR CREAR EN FASE 2
        # 
        # auditoria = AuditoriaSeguridad(
        #     usuario_id=usuario_id,
        #     administrador_id=administrador_id,
        #     accion='reset_password',
        #     ip_address=request.remote_addr,
        #     user_agent=request.headers.get('User-Agent'),
        #     fecha_hora=datetime.utcnow(),
        #     detalles='Reseteo manual por super_admin'
        # )
        # db.session.add(auditoria)
        # db.session.commit()
        
    except Exception as e:
        print(f"âš ï¸ [AUDITORÃA] Error registrando reseteo: {e}")
        
@app.route('/obtener_usuarios_panaderia/<int:panaderia_id>')
@login_required
def obtener_usuarios_panaderia(panaderia_id):
    """Obtener usuarios de una panaderÃ­a especÃ­fica (solo super_admin)"""
    if current_user.rol != 'super_admin':
        return jsonify([])
    
    try:
        usuarios = Usuario.query.filter_by(panaderia_id=panaderia_id).all()
        usuarios_data = []
        
        for usuario in usuarios:
            usuarios_data.append({
                'id': usuario.id,
                'username': usuario.username,
                'nombre_completo': usuario.nombre_completo,
                'rol': usuario.rol,
                'activo': usuario.activo
            })
        
        return jsonify(usuarios_data)
        
    except Exception as e:
        return jsonify([])
    
@app.route('/obtener_datos_cliente/<int:cliente_id>')
@login_required
def obtener_datos_cliente(cliente_id):
    """Obtener datos de un cliente especÃ­fico para ediciÃ³n"""
    if current_user.rol != 'super_admin':
        return jsonify({'success': False, 'error': 'No autorizado'})
    
    try:
        from models import ConfiguracionPanaderia
        cliente = ConfiguracionPanaderia.query.get_or_404(cliente_id)
        
        return jsonify({
            'success': True,
            'data': {
                'id': cliente.id,
                'nombre_panaderia': cliente.nombre_panaderia,
                'telefono_contacto': cliente.telefono_contacto,
                'direccion': cliente.direccion,
                'tipo_licencia': cliente.tipo_licencia,
                'max_usuarios': cliente.max_usuarios,
                'fecha_expiracion': cliente.fecha_expiracion.strftime('%Y-%m-%d') if cliente.fecha_expiracion else None,
                'dias_gracia': cliente.dias_gracia,
                'razon_social': cliente.razon_social,
                'nit': cliente.nit
            }
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/editar_cliente', methods=['POST'])
@login_required
def editar_cliente():
    """Editar datos de un cliente existente"""
    if current_user.rol != 'super_admin':
        return jsonify({'success': False, 'error': 'No autorizado'})
    
    try:
        from models import ConfiguracionPanaderia
        cliente_id = request.form.get('cliente_id')
        cliente = ConfiguracionPanaderia.query.get_or_404(cliente_id)
        
        # Actualizar datos
        cliente.nombre_panaderia = request.form.get('nombre_panaderia')
        cliente.telefono_contacto = request.form.get('telefono_contacto')
        cliente.direccion = request.form.get('direccion')
        cliente.tipo_licencia = request.form.get('tipo_licencia')
        cliente.max_usuarios = int(request.form.get('max_usuarios'))
        cliente.dias_gracia = int(request.form.get('dias_gracia', 7))
        cliente.razon_social = request.form.get('razon_social')
        cliente.nit = request.form.get('nit')
        
        # Manejar fecha de expiraciÃ³n
        fecha_expiracion = request.form.get('fecha_expiracion')
        if cliente.tipo_licencia != 'local' and fecha_expiracion:
            cliente.fecha_expiracion = datetime.strptime(fecha_expiracion, '%Y-%m-%d').date()
        elif cliente.tipo_licencia == 'local':
            cliente.fecha_expiracion = None
        
        db.session.commit()
        
        return jsonify({'success': True, 'message': 'Cliente actualizado correctamente'})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)})
    
# =============================================
# ðŸ†• RUTAS PARA LOS 3 BOTONES DE GESTIÃ“N DE CLIENTES (VERSIÃ“N CORREGIDA)
# =============================================

@app.route('/obtener_datos_cliente_super/<int:cliente_id>')
@login_required
def obtener_datos_cliente_super(cliente_id):
    """Obtener datos de un cliente especÃ­fico para ediciÃ³n (SUPER ADMIN)"""
    if current_user.rol != 'super_admin':
        return jsonify({'success': False, 'error': 'No autorizado'})
    
    try:
        from models import ConfiguracionPanaderia
        cliente = ConfiguracionPanaderia.query.get_or_404(cliente_id)
        
        # Determinar estado de suscripciÃ³n
        estado_suscripcion = 'activa'
        if cliente.tipo_licencia != 'local' and cliente.fecha_expiracion:
            from datetime import datetime
            if cliente.fecha_expiracion < datetime.now().date():
                estado_suscripcion = 'expirada'
            elif (cliente.fecha_expiracion - datetime.now().date()).days <= 7:
                estado_suscripcion = 'por_vencer'
        
        return jsonify({
            'success': True,
            'data': {
                'id': cliente.id,
                'nombre_panaderia': cliente.nombre_panaderia,
                'telefono_contacto': cliente.telefono_contacto,
                'direccion': cliente.direccion,
                'tipo_licencia': cliente.tipo_licencia,
                'max_usuarios': cliente.max_usuarios,
                'fecha_expiracion': cliente.fecha_expiracion.strftime('%Y-%m-%d') if cliente.fecha_expiracion else None,
                'dias_gracia': cliente.dias_gracia,
                'razon_social': cliente.razon_social,
                'nit': cliente.nit,
                'estado_suscripcion': estado_suscripcion
            }
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/editar_cliente_super', methods=['POST'])
@login_required
def editar_cliente_super():
    """Editar datos de un cliente existente (SUPER ADMIN)"""
    if current_user.rol != 'super_admin':
        return jsonify({'success': False, 'error': 'No autorizado'})
    
    try:
        from models import ConfiguracionPanaderia
        from datetime import datetime
        
        cliente_id = request.form.get('cliente_id')
        cliente = ConfiguracionPanaderia.query.get_or_404(cliente_id)
        
        # Actualizar datos
        cliente.nombre_panaderia = request.form.get('nombre_panaderia')
        cliente.telefono_contacto = request.form.get('telefono_contacto')
        cliente.direccion = request.form.get('direccion')
        cliente.tipo_licencia = request.form.get('tipo_licencia')
        cliente.max_usuarios = int(request.form.get('max_usuarios'))
        cliente.dias_gracia = int(request.form.get('dias_gracia', 7))
        cliente.razon_social = request.form.get('razon_social')
        cliente.nit = request.form.get('nit')
        
        # Manejar fecha de expiraciÃ³n
        fecha_expiracion = request.form.get('fecha_expiracion')
        if cliente.tipo_licencia != 'local' and fecha_expiracion:
            cliente.fecha_expiracion = datetime.strptime(fecha_expiracion, '%Y-%m-%d').date()
        elif cliente.tipo_licencia == 'local':
            cliente.fecha_expiracion = None
        
        db.session.commit()
        
        return jsonify({'success': True, 'message': 'Cliente actualizado correctamente'})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/renovar_suscripcion_super', methods=['POST'])
@login_required
def renovar_suscripcion_super():
    """Renovar suscripciÃ³n de un cliente (SUPER ADMIN)"""
    if current_user.rol != 'super_admin':
        return jsonify({'success': False, 'error': 'No autorizado'})
    
    try:
        from models import ConfiguracionPanaderia
        from datetime import datetime
        
        cliente_id = request.form.get('cliente_id')
        cliente = ConfiguracionPanaderia.query.get_or_404(cliente_id)
        
        # Actualizar datos
        cliente.tipo_licencia = request.form.get('tipo_licencia')
        cliente.max_usuarios = int(request.form.get('max_usuarios'))
        
        # Manejar fecha de expiraciÃ³n para licencias en la nube
        if cliente.tipo_licencia != 'local':
            nueva_fecha = request.form.get('nueva_fecha_expiracion')
            if nueva_fecha:
                cliente.fecha_expiracion = datetime.strptime(nueva_fecha, '%Y-%m-%d').date()
        else:
            cliente.fecha_expiracion = None
        
        db.session.commit()
        
        return jsonify({'success': True, 'message': 'SuscripciÃ³n renovada correctamente'})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/acceder_panaderia_super/<int:panaderia_id>/<int:usuario_id>')
@login_required
def acceder_panaderia_super(panaderia_id, usuario_id):
    """Acceder a una panaderÃ­a como super admin - VERSIÃ“N FUNCIONAL"""
    if current_user.rol != 'super_admin':
        return jsonify({'success': False, 'error': 'No autorizado'})
    
    try:
        from models import Usuario
        usuario_target = Usuario.query.filter_by(id=usuario_id, panaderia_id=panaderia_id).first()
        
        if not usuario_target:
            return jsonify({'success': False, 'error': 'Usuario no encontrado en esta panaderÃ­a'})
        
        # âœ… âœ… âœ… CORRECCIÃ“N CRÃTICA: CAMBIAR LA SESIÃ“N âœ… âœ… âœ…
        session['panaderia_id'] = panaderia_id
        print(f"âœ… Super usuario accediendo a panaderÃ­a: {panaderia_id} como usuario: {usuario_target.username}")
        
        return jsonify({
            'success': True, 
            'message': f'Acceso concedido a panaderÃ­a {panaderia_id}'
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}) 
    
@app.route('/acceder_panaderia/<int:panaderia_id>')
@login_required
def acceder_panaderia(panaderia_id):
    """Acceso remoto para super usuario a cualquier panaderÃ­a"""
    print(f"ðŸŽ¯ DEBUG: Iniciando acceso remoto a panaderÃ­a {panaderia_id}")
    
    if not es_super_usuario():
        print("âŒ DEBUG: No es super usuario - bloqueando acceso")
        flash('No tienes permisos para acceso remoto', 'error')
        return redirect(url_for('dashboard'))
    
    print(f"âœ… DEBUG: Es super usuario - activando acceso remoto")
    
    # Guardar en variable SEPARADA, NO sobreescribir panaderia_id
    session['panaderia_remota'] = panaderia_id
    print(f"âœ… DEBUG: panaderia_remota guardado: {session.get('panaderia_remota')}")
    
    panaderia = Panaderia.query.get(panaderia_id)
    print(f"âœ… DEBUG: PanaderÃ­a encontrada: {panaderia.nombre if panaderia else 'NO ENCONTRADA'}")
    
    if panaderia:
        flash(f'ðŸ”§ Acceso remoto activado: {panaderia.nombre}', 'success')
    else:
        flash('ðŸ”§ Acceso remoto activado', 'success')
    
    print(f"âœ… DEBUG: Redirigiendo a dashboard")
    return redirect(url_for('dashboard'))

@app.route('/salir_acceso_remoto')
@login_required
def salir_acceso_remoto():
    """Salir del modo acceso remoto"""
    if 'panaderia_remota' in session:
        panaderia_id = session['panaderia_remota']
        session.pop('panaderia_remota')
        flash('Has salido del modo acceso remoto', 'info')
    return redirect(url_for('gestion_clientes'))

 
app.config['TEMPLATES_AUTO_RELOAD'] = True
app.config['SEND_FILE_MAX_AGE_DEFAULT'] = 0

if __name__ == '__main__':
    app.run(host='0.0.0.0', debug=True)